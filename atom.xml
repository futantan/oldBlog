<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Prayer&#39;s blog</title>
  
  <subtitle>爱这个世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.futantan.com/"/>
  <updated>2019-01-21T10:56:21.999Z</updated>
  <id>http://www.futantan.com/</id>
  
  <author>
    <name>Prayer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>compose</title>
    <link href="http://www.futantan.com/2019/01/20/fp-compose/"/>
    <id>http://www.futantan.com/2019/01/20/fp-compose/</id>
    <published>2019-01-20T14:59:49.000Z</published>
    <updated>2019-01-21T10:56:21.999Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/2019-1-20-compose.jpg" alt=""></p><p>在函数式编程的世界中，函数是基本单元，通过对一些函数的排列组合，构建了功能更加强大的函数，而这些的基础，是函数组合。</p><a id="more"></a><p>我们通常会使用函数嵌套的方式来做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(g(h(x)))</span><br></pre></td></tr></table></figure></p><p>这是非常典型的例子，面向过程，将 <code>h(x)</code> 的结果给 <code>g</code>，然后再调用 <code>f</code>。当可读性不好的时候，我们会选择引入中间变量，将中间的计算结果赋值给一个变量，然后再进行下一步的操作。</p><p>那么在函数式的世界中，是如何处理的呢？</p><p>假设我们定义一个操作 </p><p>$$\circ : (f \circ g)(x)=f(g(x))$$</p><p>那么上面的 <code>f(g(h(x)))</code> 可以表示为</p><p>$$(f \circ g \circ h)(x)$$</p><p>Beautiful math！这就是函数组合，左边的部分，由三个函数，组合成了一个全新的函数。</p><p>那么在编程的世界中，我们是如何做的呢？<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(f . g . h) x</span><br></pre></td></tr></table></figure></p><p>这是 haskell 中的代码，与数学定义完全一致！</p><p>接下来我们尝试在 JavaScript 中来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = </span><br><span class="line">  (...fns) =&gt; <span class="function">(<span class="params">x</span>) =&gt;</span> fns.reduceRight(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> curr(prev), x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addOne = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addOneThenDouble = compose(double, addOne)</span><br><span class="line"><span class="built_in">console</span>.log(addOneThenDouble(<span class="number">3</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></p><p>非常简单，<code>fns</code> 是传入的所有函数的集合，然后从右向左，依次进行函数调用，将上一次的结果作为下一次调用的输入，最终得到结果。</p><p>对于 <code>compse</code> 的接口，最右的函数参数个数可以任意，然后其他的所有函数接收一个参数，并返回一个值，为了满足这个需求，修改代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> putToArray = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Array</span>.isArray(x) ? x : [x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compose =</span><br><span class="line">  (...fns) =&gt;</span><br><span class="line">    (...args) =&gt;</span><br><span class="line">      fns.reduceRight(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span></span><br><span class="line">        curr.apply(<span class="literal">null</span>, putToArray(prev)), args)</span><br></pre></td></tr></table></figure></p><p>完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/2019-1-20-compose.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在函数式编程的世界中，函数是基本单元，通过对一些函数的排列组合，构建了功能更加强大的函数，而这些的基础，是函数组合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="fp" scheme="http://www.futantan.com/tags/fp/"/>
    
  </entry>
  
  <entry>
    <title>2019，始。</title>
    <link href="http://www.futantan.com/2019/01/01/2019-begins/"/>
    <id>http://www.futantan.com/2019/01/01/2019-begins/</id>
    <published>2019-01-01T08:31:16.000Z</published>
    <updated>2019-01-14T08:38:46.080Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/2019-caleb-jones-131206-unsplash.jpg" alt=""></p><p>人们总是愿意期望未来，而不是回顾过去，所以总是在一个地方摔倒，再爬起来，拍拍尘土，咒骂一句，头也不回的继续走下去。</p><a id="more"></a><p>至于为什么摔倒了，才不会去深究，毕竟谁会承认自己的无能，和自己过意不去呢。他们这样走下去，走的人多了，同行的也就多了，群体性的行为会给他们力量，让他们在前行的路上彼此温暖和给予勇气。</p><p>以上，是一个遵从内心选择，走了一条僻静小路的人，看到一群人的时候，说那是酸葡萄的样子。</p><p>距离上次的博客更新过去了一年半，想起写作最频繁的时候，还是学生时代。在海滩边捡贝壳，觉得每一片都非常漂亮，想要分享给世界，然后久了发现，世界上的这些东西，没有什么是独一无二的。而那些灿烂的星河，在那里早有人总结和分享好了。</p><p>如果想的太透彻，大概就没什么意思了，所以还是要像个孩子一样，为一点小发现惊奇激动，欢呼雀跃。</p><p>2018 年大概是心智启蒙的一年，开始真正意义上的思考这一切。有可能是阅历稍微多了一些，结了婚，有了家庭，看问题和思考的角度都更多了一些。</p><p>我们期望未来，期望改变，而做出的努力太少，所以每年都是一样的满怀憧憬，每年都一样的重蹈覆辙。我不愿如此。</p><p>那就做吧。<br>Happy new year，happy hacking!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/2019-caleb-jones-131206-unsplash.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;人们总是愿意期望未来，而不是回顾过去，所以总是在一个地方摔倒，再爬起来，拍拍尘土，咒骂一句，头也不回的继续走下去。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>迈向开源的第一步——发布属于自己的 npm 包</title>
    <link href="http://www.futantan.com/2017/10/29/publish-npm-package/"/>
    <id>http://www.futantan.com/2017/10/29/publish-npm-package/</id>
    <published>2017-10-29T13:55:23.000Z</published>
    <updated>2017-11-14T06:31:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i0.wp.com/realityonweb.com/wp-content/uploads/2015/06/npm.logo_.png?resize=262%2C103" alt="NPM"></p><a id="more"></a><blockquote><p>本文整理自 <a href="https://egghead.io/courses/publish-javascript-packages-on-npm" target="_blank" rel="noopener">egghead.io</a></p></blockquote><h2 id="添加版本控制"><a href="#添加版本控制" class="headerlink" title="添加版本控制"></a>添加版本控制</h2><p>输入以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ftt-sensitive-words</span><br><span class="line">$ <span class="built_in">cd</span> ftt-sensitive-words </span><br><span class="line">$ git init</span><br><span class="line">$ git remote add origin git@github.com:futantan/ftt-sensitive-words.git</span><br><span class="line">$ touch README.md</span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit -m <span class="string">"Initial commit"</span></span><br><span class="line">$ git push --<span class="built_in">set</span>-upstream origin master</span><br></pre></td></tr></table></figure></p><blockquote><p>同时需要在 .gitignore 文件中加入 node_modules 等目录和文件</p></blockquote><p>上述命令执行完毕之后，我们已经在 <code>github</code> 上初始化了我们的代码仓库，接下来需要初始化 <code>npm</code> 配置。</p><h2 id="初始化-npm-配置"><a href="#初始化-npm-配置" class="headerlink" title="初始化 npm 配置"></a>初始化 npm 配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>在随后的问答中，填入你想要的信息，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">description: Filter out a list of sensitive words</span><br><span class="line">entry point: build/index.js</span><br><span class="line">keywords: filter, filtering, sensitive, words</span><br></pre></td></tr></table></figure><blockquote><p>注意这里的 <code>entry point</code>，我们会在后面解释</p></blockquote><h2 id="添加-build-脚本"><a href="#添加-build-脚本" class="headerlink" title="添加 build 脚本"></a>添加 build 脚本</h2><p>为了能够使用 <code>ES6</code> 的语言特性，我们将会使用 <code>babel</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-cli babel-preset-latest --save-dev</span><br></pre></td></tr></table></figure><p>然后在 <code>package.json</code> 的 <code>scripts</code> 中添加如下命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build"</span>: <span class="string">"babel src -d build"</span></span><br></pre></td></tr></table></figure><p>在运行 <code>npm run build</code> 之后，会将 <code>src</code> 目录中的代码「编译」（转换）之后放入 <code>build</code> 文件夹中。这也就是在第二步中，我们将 <code>entry point</code> 设置为 <code>build/index.js</code> 的原因。</p><p>同时，需要为 <code>babel</code> 做一些配置，将下面的代码放入 <code>package.json</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"babel"</span>: &#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"latest"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>接下来新建 <code>src/index.js</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><p>这时我们运行 <code>npm run build</code>，就会在 <code>build/</code> 文件夹中找到转化之后的代码。</p><h2 id="添加-dev-脚本"><a href="#添加-dev-脚本" class="headerlink" title="添加 dev 脚本"></a>添加 dev 脚本</h2><p>为了能够在每次改动 <code>src</code> 目录中代码的时候，自动运行 <code>build</code>，我们添加 <code>watch</code> 这个包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install watch --save-dev</span><br></pre></td></tr></table></figure><p>在 <code>package.json</code> 的 <code>scripts</code> 中添加 <code>dev</code> 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;watch &apos;npm run build&apos; src&quot;</span><br></pre></td></tr></table></figure></p><p>运行 <code>npm run dev</code>，现在可以修改一下 <code>src/index.js</code> 文件的内容，查看效果。</p><h2 id="添加-test-脚本"><a href="#添加-test-脚本" class="headerlink" title="添加 test 脚本"></a>添加 test 脚本</h2><p>接下来为我们的项目添加 test 命令，这里我们使用 <code>jest</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install jest --save-dev</span><br></pre></td></tr></table></figure><p>在 <code>package.json</code> 的 <code>scripts</code> 中添加 <code>test</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"test"</span>: <span class="string">"jest"</span></span><br></pre></td></tr></table></figure><p>新建 <code>src/index.test.js</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/index.test.js */</span></span><br><span class="line"><span class="keyword">import</span> sensitiveWords <span class="keyword">from</span> <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'says hello world'</span>, () =&gt; &#123;</span><br><span class="line">  expect(sensitiveWords()).toBe(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改 <code>src/index.js</code> 文件的内容，来查看 <code>npm test</code> 的运行结果。和 <code>build</code> 命令一样，我们也可以监听文件的变化，自动运行测试命令。在 <code>package.json</code> 的 <code>scripts</code> 中添加如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;test:watch&quot;: &quot;npm test -- --watch&quot;</span><br></pre></td></tr></table></figure><h2 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h2><p>在开发的过程中，可以开两个 terminal 窗口，分别运行以下两个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm run dev</span><br><span class="line">$ npm run test:watch</span><br></pre></td></tr></table></figure><p>修改测试文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/index.test.js */</span></span><br><span class="line"><span class="keyword">import</span> sensitiveWords <span class="keyword">from</span> <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'replaces blacklisted words with aasterisks'</span>, () =&gt; &#123;</span><br><span class="line">  expect(sensitiveWords(</span><br><span class="line">    <span class="string">'The name of the NX will be the Nintedo Switch'</span>,</span><br><span class="line">    [<span class="string">'switch'</span>]</span><br><span class="line">  ))</span><br><span class="line">    .toBe(<span class="string">'The name of the NX will be the Nintedo ***'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改 <code>index.js</code> 文件内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/index.js */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (content, words) =&gt; (</span><br><span class="line">  content.replace(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">RegExp</span>(words.join(<span class="string">'|'</span>), <span class="string">'i'</span>),</span><br><span class="line">    <span class="string">'***'</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>再添加一个测试用例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/index.test.js */</span></span><br><span class="line">test(<span class="string">'replaces multiple instances of blacklisted words'</span>, () =&gt; &#123;</span><br><span class="line">  expect(sensitiveWords(</span><br><span class="line">    <span class="string">'The name of the NX will be the Nintedo Switch. The switch will be awesome!'</span>,</span><br><span class="line">    [<span class="string">'switch'</span>]</span><br><span class="line">  ))</span><br><span class="line">    .toBe(<span class="string">'The name of the NX will be the Nintedo ***. The *** will be awesome!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这时候会发现测试挂了，第二个 <code>switch</code> 并没有被替换掉，（测试的重要性！）<br>修改 <code>index.js</code> 文件 <code>new RegExp(words.join(&#39;|&#39;), &#39;ig&#39;)</code><br>测试通过！！！</p><h2 id="使用-npm-link-进行测试"><a href="#使用-npm-link-进行测试" class="headerlink" title="使用 npm link 进行测试"></a>使用 npm link 进行测试</h2><p>在将代码发布到 npm 之前，我们可以作为库的使用者，试着使用我们的库。<code>npm link</code> 可以满足我们的需求<br>name of the package: ftt-sensitive-words</p><p>运行如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm link</span><br><span class="line">/usr/local/lib/node_modules/ftt-sensitive-words -&gt; /Users/xxx/ftt-sensitive-words</span><br><span class="line">$ mkdir some-project</span><br><span class="line">$ cd some-project</span><br><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure></p><p>这时运行 <code>npm link ftt-sensitive-words</code>，就可以将我们之前写的包 link 到当前的 <code>node_modules</code> 中，新建一个 <code>index.js</code> 文件，使用一下我们的代码吧！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> senstiveWords = <span class="built_in">require</span>(<span class="string">'ftt-sensitive-words'</span>).default</span><br><span class="line"><span class="keyword">const</span> filtered = senstiveWords(</span><br><span class="line">  <span class="string">'The new apple macbook pro will have a touchbar'</span>,</span><br><span class="line">  [<span class="string">'pro'</span>, <span class="string">'touchbar'</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(filtered)</span><br></pre></td></tr></table></figure><p>$ node index.js</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>为了能够让使用者更好地使用，在 <code>README.md</code> 中可以写一些使用的示例，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> senstiveWords = <span class="built_in">require</span>(<span class="string">'ftt-sensitive-words'</span>).default</span><br><span class="line"><span class="keyword">const</span> filtered = senstiveWords(</span><br><span class="line">  <span class="string">'The new apple macbook pro will have a touchbar'</span>,</span><br><span class="line">  [<span class="string">'pro'</span>, <span class="string">'touchbar'</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(filtered)</span><br><span class="line"><span class="comment">// The new apple macbook *** will have a ***</span></span><br></pre></td></tr></table></figure><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>在 <code>package.json</code> 的 <code>scripts</code> 中添加 <code>prepublish</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;prepublish&quot;: &quot;npm run build&quot;</span><br></pre></td></tr></table></figure><p>这样可以确保在 publish 之前，运行过 build。<br>这个时候还存在一个问题，我们的源码是在 <code>src</code> 文件中，我们希望库的使用者，使用 <code>build</code> 目录中的代码，所以，<code>src</code> 文件中的东西不应该作为 npm 包的一部分，这时候 <code>.npmignore</code> 就出场了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch .npmignore</span><br></pre></td></tr></table></figure><p>在 <code>.npmignore</code> 文件中加入 <code>src/</code>。 <code>.npmignore</code> 与 <code>.gitignore</code> 功能类似，一个是针对 npm，一个是针对 git。</p><p>之后运行如下命令就可以发布了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm adduser</span><br><span class="line">$ npm publish</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>为了更方便地管理代码的更新与发布，推荐使用 <code>np</code> 这个库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install np --save-dev</span><br></pre></td></tr></table></figure><p>在 <code>package.json</code> 的 <code>scripts</code> 中添加 <code>release</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;release&quot;: &quot;np&quot;</span><br></pre></td></tr></table></figure><p>在修改代码之后，可以运行如下命令来进行更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run release</span><br></pre></td></tr></table></figure><blockquote><p>Happy Hacking~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i0.wp.com/realityonweb.com/wp-content/uploads/2015/06/npm.logo_.png?resize=262%2C103&quot; alt=&quot;NPM&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.futantan.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="开源" scheme="http://www.futantan.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="npm" scheme="http://www.futantan.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>解决 React Router location 得不到更新问题</title>
    <link href="http://www.futantan.com/2017/10/28/react-router-not-updated-in/"/>
    <id>http://www.futantan.com/2017/10/28/react-router-not-updated-in/</id>
    <published>2017-10-28T07:03:22.000Z</published>
    <updated>2017-10-28T08:03:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/redux-and-react-router.png" alt=""><br>React Router 可以帮助我们在单页面应用中管理 url，但是如果理解不当，也会存在一些潜在的 bug。</p><a id="more"></a><p>例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HeaderComp = <span class="function">(<span class="params">&#123;location&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;&#123;location&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Header = connect(mapStateToProps)(withRouter(HeaderComp))</span></span><br></pre></td></tr></table></figure><p>上述代码中，先是使用 <code>withRouter</code> 期望将 <code>location</code> 参数传入 <code>HeaderComp</code>，之后又 connect 到了 redux store。但是这里会发现，<code>location</code> 的值不会随着浏览器 url 的变化而更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  selector.shouldComponentUpdate = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextProps !== selector.props || selector.error) &#123;</span><br><span class="line">  selector.shouldComponentUpdate = <span class="literal">true</span></span><br><span class="line">  selector.props = nextProps</span><br><span class="line">  selector.error = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是 <code>react-redux</code> 源码的片段，在 connect 所生成的高阶组件中，有如上两个片段。在每次 <code>render</code> 的时候，会将 <code>shouldComponentUpdate</code> 置为 false，之后每次比较 <code>props</code> 和 <code>nextProps</code> 是否不同，如果不同，才去触发 render。</p><p>React Router 是通过 <code>context</code> 来将路由等信息通知到下游的组件的，所以，上述代码中 <code>Header</code> 的 <code>props</code> 中并不会有路由的信息，在 <code>shouldComponentUpdate</code> 方法中判定为 false，因此 HeaderComp 不会更新 location。</p><p>解决的办法也很直接，将上述的代码改为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">withRouter(connect(mapStateToProps)(HeaderComp))</span><br></pre></td></tr></table></figure></p><p>这样一来，locatin 等参数会注入到 connect 所生成的高阶组件中， <code>shouldComponentUpdate</code> 会判定为 true，我们就拿到了期待的路由信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/redux-and-react-router.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;React Router 可以帮助我们在单页面应用中管理 url，但是如果理解不当，也会存在一些潜在的 bug。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React Router" scheme="http://www.futantan.com/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>UIKit 中协议与值类型编程实战</title>
    <link href="http://www.futantan.com/2016/06/18/wwdc-2016-session-419/"/>
    <id>http://www.futantan.com/2016/06/18/wwdc-2016-session-419/</id>
    <published>2016-06-18T08:06:01.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为 <a href="https://developer.apple.com/videos/play/wwdc2016/419/" target="_blank" rel="noopener">WWDC 2016 Session 419</a> 的部分内容笔记。强烈推荐观看。</p><a id="more"></a><h2 id="设计师来需求了"><a href="#设计师来需求了" class="headerlink" title="设计师来需求了"></a>设计师来需求了</h2><p>在我们的 App 中，通常需要自定义一些视图。例如下图：</p><p><img src="/media/14662537887434.jpg" alt=""></p><p>我们可能会在很多地方用到右边为内容，左边有个装饰视图到样式，为了代码的通用性，我们在 <code>UITableViewCell</code> 的基础上，封装了一层 <code>DecoratingLayout</code>，然后再让子类继承它，从而实现这一类视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratingLayout</span> : <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">UIView</span></span><br><span class="line">    <span class="keyword">var</span> decoration: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Perform layout...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>但是代码这样组织的话，因为继承自 <code>UITableViewCell</code>，所以对于其他类型的 view 就不能使用了。我们开始重构。</p><p><img src="/media/14662540724528.jpg" alt=""></p><p>我们需要让视图布局的功能独立与具体的 view 类型，无论是 <code>UITableViewCell</code>、<code>UIView</code>、还是 <code>SKNode</code>（Sprite Kit 中的类型）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">UIView</span></span><br><span class="line">    <span class="keyword">var</span> decoration: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Perform layout...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们使用结构体 <code>DecoratingLayout</code> 来表示这种 layout。相比于之前的方式，现在只要在具体的实现中，创建一个 <code>DecoratingLayout</code> 就可以实现布局的功能。代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamCell</span> : <span class="title">UITableViewCell</span> </span>&#123;   ...</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;<span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)decoratingLayout.layout(<span class="keyword">in</span>: bounds)&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DreamDetailView</span> : <span class="title">UIView</span> </span>&#123;   ...</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;<span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)decoratingLayout.layout(<span class="keyword">in</span>: bounds)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意观察上面的代码，在 <code>UITableViewCell</code> 和 <code>UIView</code> 类型的 view 中，布局功能和具体的视图已经解耦，我们都可以使用 strut 的代码来完成布局功能。</p><p>通过这种方式实现的布局，对于测试来说也更加的方便：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLayout</span><span class="params">()</span></span> &#123;<span class="keyword">let</span> child1 = <span class="type">UIView</span>()<span class="keyword">let</span> child2 = <span class="type">UIView</span>()<span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">XCTAssertEqual</span>(child1.frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))<span class="type">XCTAssertEqual</span>(child2.frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的野心远不止于此。这里我们也想要在 <code>SKNode</code> 上使用上面的布局方式。看如下的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewDecoratingLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">UIView</span></span><br><span class="line">    <span class="keyword">var</span> decoration: <span class="type">UIView</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    content.frame = ...      decoration.frame = ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeDecoratingLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">SKNode</span></span><br><span class="line">    <span class="keyword">var</span> decoration: <span class="type">SKNode</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">        content.frame = ...       decoration.frame = ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意观察上面的代码，除了 <code>content</code> 和 <code>decoration</code> 的类型不一样之外，其他的都是重复的代码，<strong>重复就是罪恶！</strong></p><p>那么我们如何才能消除这些重复代码呢？在 <code>DecoratingLayout</code> 中，唯一用到 <code>content</code> 和 <code>decoration</code> 的地方，是获取它的 <code>frame</code> 属性，所以，如果这两个 property 的类型信息中，能够提供 frame 就可以了，于是我们想到了使用 protocol 作为类型（type）来使用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> frame: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是上面两个重复的代码片段又可以合并为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">Layout</span></span><br><span class="line">    <span class="keyword">var</span> decoration: <span class="type">Layout</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    content.frame = ...      decoration.frame = ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够在使用 <code>DecoratingLayout</code> 的时候传入 <code>UIView</code> 和 <code>SKNode</code>，我们需要让它们遵守 <code>Layout</code> 协议，只需要像下面这样声明一下就可以了，因为二者都已满足协议的要求。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span>: <span class="title">Layout</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span>: <span class="title">Layout</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里讲一点我自己的理解，DreamCell 和 DreamDetailView 中能够使用同一套布局代码，是因为传递进去的 view 都拥有公共的父类 UIView，它提供了 frame 信息，而 UIView 和 SKNode 则不行，这里我们使用 protocol 作为类型参数，可以很好的解决这一问题。</p></blockquote><h2 id="引入范型"><a href="#引入范型" class="headerlink" title="引入范型"></a>引入范型</h2><p>然而，目前的代码中是存在一个问题的，<code>content</code> 和 <code>decoration</code> 的具体类型信息在实际中可能是不一致的，因为这里我们只要求了它们的类型信息中提供 <code>frame</code> 属性，而并没有规定它们是相同的类型，例如 <code>content</code> 可能是 <code>UIView</code> 而 <code>decoration</code> 是 <code>SKNode</code> 类型，这与我们的期望是不符的。</p><p>这里我们可以通过引入范型来解决：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span>: <span class="title">Layout</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">Child</span></span><br><span class="line">    <span class="keyword">var</span> decoration: <span class="type">Child</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    content.frame = ...      decoration.frame = ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用范型，我们就保证了 <code>content</code> 和 <code>decoration</code> 类型相同。</p><h2 id="需求又来啦"><a href="#需求又来啦" class="headerlink" title="需求又来啦"></a>需求又来啦</h2><p>设计师说，来，小伙子，完成下面的布局。<br><img src="/media/14662493219132.jpg" alt=""></p><p>为了实现上图的效果，我们仿照之前的写法，实现如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayout</span>&lt;<span class="title">Child</span>: <span class="title">Layout</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> children: [<span class="type">Child</span>]</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/14662496073675.jpg" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span>: <span class="title">Layout</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content: <span class="type">Child</span></span><br><span class="line">    <span class="keyword">var</span> decoration: <span class="type">Child</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    content.frame = ...      decoration.frame = ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我又将前面的代码拿了过来，方便查看。</p><p>我们将上面的两种布局方式组合起来，就可以得到下面的效果：<br><img src="/media/14662496417592.jpg" alt=""></p><h2 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h2><p>那么如何才能将两种布局方式组合起来呢？</p><p>来观察我们之前定义的协议 <code>Layout</code>，其实我们关心的并不是 <code>Layout</code> 中的 <code>frame</code>，我们的目的是，让 <code>Layout</code> 能够在特定的上下文中进行相应的布局，所以我们来修改代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>Layout</code> 的语义变成了：该类型能够在特定的 <code>CGRect</code> 中进行相应的布局。</p><p>同时我们也需要修改代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span>: <span class="title">Layout</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span>: <span class="title">Layout</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这里省略了使用 <code>UIView</code> 和 <code>SKNode</code> 的 frame 来进行布局的代码。<br>于是我们的代码变成了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>&#123; ... &#125;<span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>看到这里可能有点晕，其实代码表达的意思是，<code>DecoratingLayout</code> 遵循 <code>Layout</code> 协议，而它的 <code>content</code> 和 <code>decoration</code> 两个 property 也同样遵循该协议，即可以在特定的 <code>CGRect</code> 中完成布局操作。而两个结构体本身就包含 <code>layout</code> 操作，所以不需要任何其他的代码，结构体做的事情就是，在自己进行 <code>layout</code> 操作的基础上，将其传递给两个 property 然后分别进行 <code>layout</code>，这就完成了<strong>组合</strong>。</p><p>组合之后的执行代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decoration = <span class="type">CascadingLayout</span>(children: accessories) <span class="comment">// 左边</span><span class="keyword">var</span> composedLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration) <span class="comment">// 整体</span>composedLayout.layout(<span class="keyword">in</span>: rect) <span class="comment">// 执行 layout 操作</span></span><br></pre></td></tr></table></figure><h2 id="On-step-further"><a href="#On-step-further" class="headerlink" title="On step further"></a>On step further</h2><p><img src="/media/14662493219132.jpg" alt=""></p><p>注意观察上面的视图，视图是有层次结构的，所以我们需要在布局的时候，能够拿到这个子视图数组，之前的视实现方式中，只能布局单个的视图，没有办法拿到整个视图数组进行操作。<br>我们来修改 <code>Layout</code> 的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>    <span class="keyword">var</span> contents: [<span class="type">Layout</span>] &#123; <span class="keyword">get</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>这里增加了一个可读属性，返回一个 <code>Layout</code> 数组。同样，这里的代码存在一个问题，contents 可以为不同的 Layout 类型，例如 <code>[UIView(), SKNode()]</code>，所以为了让 <code>contents</code> 中的类型一直，我们使用 <code>associatedtype</code>，将上面的代码改写为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>&#123;    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></span><br><span class="line">    associatedtype <span class="type">Content</span>    <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>相应的 struct 改为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewDecoratingLayout</span> : <span class="title">Layout</span> </span>&#123;   ...   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>   <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">UIView</span>   <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeDecoratingLayout</span> : <span class="title">Layout</span> </span>&#123;   ...   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>   <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">SKNode</span>   <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>重复就是罪恶啊！可以看到，这里唯一的不同只是 <code>Content</code> 的类型信息。这里我们还是利用强大的范型来解决：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>&#123;   ...   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>   <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span>   <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>这里，当 <code>Child</code> 范型确定的时候，<code>Child.Content</code> 的类型信息也相应地确定了，所以可以使用上面的代码来消除重复。</p><p>范型牛逼！*3</p><p>别激动的太早，我们的代码中还存在一个问题。目前我们的代码长这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>&#123;    <span class="keyword">var</span> content: <span class="type">Child</span>    <span class="keyword">var</span> decoration: <span class="type">Child</span>    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>    <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span>    <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>content</code> 和 <code>decoration</code> 使用的是同样的 layout 方式，这与我们的预期是不符的。我们的需求时视图左边和右边使用不同的布局方式。然而我们又需要这个范型的方式来保证它们俩实际的数据类型是相同的，这里需要使用两个范型信息，但是限制它们的实际数据类型相同。修改后的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>, <span class="title">Decoration</span> : <span class="title">Layout</span></span></span><br><span class="line"><span class="class"><span class="title">where</span> <span class="title">Child</span>.<span class="title">Content</span> == <span class="title">Decoration</span>.<span class="title">Content</span>&gt; : <span class="title">Layout</span> </span>&#123;    <span class="keyword">var</span> content: <span class="type">Child</span>    <span class="keyword">var</span> decoration: <span class="type">Decoration</span>    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>    <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span>    <span class="keyword">var</span> contents: [<span class="type">Content</span>] &#123; <span class="keyword">get</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>以上。</p><p>再一次，推荐你在写 Swift 中定义新类型的时候，把 class 抛在脑后，尝试着从 struct 和 protocol 开始。</p><p>Happy Hacking!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2016/419/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WWDC 2016 Session 419&lt;/a&gt; 的部分内容笔记。强烈推荐观看。&lt;/p&gt;
    
    </summary>
    
      <category term="WWDC" scheme="http://www.futantan.com/categories/WWDC/"/>
    
    
      <category term="iOS" scheme="http://www.futantan.com/tags/iOS/"/>
    
      <category term="WWDC" scheme="http://www.futantan.com/tags/WWDC/"/>
    
  </entry>
  
  <entry>
    <title>Learn RxSwift The Hard Way - Geolocation (三)</title>
    <link href="http://www.futantan.com/2016/06/03/Learn-RxSwift-The-Hard-Way-Geolocation/"/>
    <id>http://www.futantan.com/2016/06/03/Learn-RxSwift-The-Hard-Way-Geolocation/</id>
    <published>2016-06-03T01:25:13.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里我们来从头实现 RxExample 的第三个例子：GeolocationExample。如果不知道如何开始，可以参考之前的几篇博文。</p><a id="more"></a><p>你可以先运行一下代码，看一下效果。每当我们改变对应用程序定位的授权，界面都会发生相应的改变。</p><h2 id="GeolocationService"><a href="#GeolocationService" class="headerlink" title="GeolocationService"></a>GeolocationService</h2><p>首先我们来看提供定位功能的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeolocationService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> (<span class="keyword">set</span>) <span class="keyword">var</span> autorized: <span class="type">Driver</span>&lt;<span class="type">Bool</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> (<span class="keyword">set</span>) <span class="keyword">var</span> location: <span class="type">Driver</span>&lt;<span class="type">CLLocationCoordinate2D</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> instance = <span class="type">GeolocationService</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我省略了 <code>init</code> 的内容，先来看接口，之后我们会回过头来看具体的实现。很显然，这里的 <code>GeolocationService</code> 是一个标准的单例。而前两个对于外部只读的变量，就是这个 Service 对外提供的接口。</p><p>不难猜测，这里的 <code>autorized</code> 表示是否有定位权限。目前知道这些就够了，先了解骨架，后面再深入细节。</p><h2 id="GeolocationViewController"><a href="#GeolocationViewController" class="headerlink" title="GeolocationViewController"></a>GeolocationViewController</h2><p>我们来看 <code>GeolocationViewController</code> 的核心代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TAG: 终极版本</span></span><br><span class="line">geolocationService</span><br><span class="line">.autorized</span><br><span class="line">.drive(noGeolocationView.rx_driveAuthorization)</span><br><span class="line">.addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><p>噫…这里的 <code>drive</code> 是什么，<code>rx_driveAuthorization</code> 又是什么？我们先来看 <code>rx_driveAuthorization</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private extension UIView &#123;</span><br><span class="line">    var rx_driveAuthorization: AnyObserver&lt;Bool&gt; &#123;</span><br><span class="line">        return UIBindingObserver(UIElement: self) &#123; view, authorized in</span><br><span class="line">            if authorized &#123;</span><br><span class="line">                view.hidden = true</span><br><span class="line">                view.superview?.sendSubviewToBack(view)</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                view.hidden = false</span><br><span class="line">                view.superview?.bringSubviewToFront(view)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.asObserver()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tip：这里将 extension 声明为 private，可以将其限制在该代码文件中，类似的效果可以参考 <a href="http://swift.gg/2016/06/02/swift-selector-syntax-sugar/" target="_blank" rel="noopener">Swift：Selector 语法糖</a></p></blockquote><p><code>rx_driveAuthorization</code> 为一个计算属性，类型为 <code>AnyObserver&lt;Bool&gt;</code>。虽然目前不知道 <code>UIBindingObserver</code> 是干什么用的，不过从代码可以推测出来，通过一个 <code>authorized</code> 布尔类型的变量来控制视图的状态。</p><p>来看 <code>UIBindingObserver</code> 的构造函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="type">UIElement</span>: <span class="type">UIElementType</span>, binding: (<span class="type">UIElementType</span>, <span class="type">Value</span>) -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure><p><code>UIElement</code> 为 UI 元素，后面为一个函数，从 <code>binding</code> 这个函数名也可以看出，当订阅的事件发生的时候，会调用这个函数。其中第二个参数 <code>Value</code> 就是这个 observer 的订阅消息类型。</p><p>理解到这里，总结一下。<code>rx_driveAuthorization</code> 为一个订阅者（observer），订阅的消息类型是 bool，然后根据这个值来作出视图的相应变化。</p><p>我们先不管上面的 <code>drive</code>，如果按照我们之前的做法，如何来实现这个功能呢？虽然不推荐，但是我们可以写出下面容易理解的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TAG: 版本1</span></span><br><span class="line">geolocationService.autorized</span><br><span class="line">    .asObservable()</span><br><span class="line">    .subscribeNext &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (autorized) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.noGeolocationView.rx_driveAuthorization.onNext(autorized)</span><br><span class="line">    &#125;</span><br><span class="line">    .addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><blockquote><p>Tip: 这里如果不用 weak self，会造成循环引用哦。</p></blockquote><p>上面的方式应该是最容易理解的。首先将 <code>autorized</code> 转为 Observable，然后订阅 next 事件，然后显式地发送 onNext 事件。虽然这种方式可行，但是有些不妥的。我们来一步一步优化。</p><p>改写成如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TAG: 版本2</span></span><br><span class="line">geolocationService.autorized</span><br><span class="line">    .asObservable()</span><br><span class="line">    .subscribe(noGeolocationView.rx_driveAuthorization)</span><br></pre></td></tr></table></figure><p>这里直接用 <code>subscribe</code> 的方式来订阅。其实如果进入源码看的话，和上面我们实现的方式差不多，不过除了 next 事件，还有 complete 等事件的处理。</p><p>好了，现在版本 2 和我们的终极版本已经很像了。我来看看，<code>drive</code> 到底做了些什么。</p><blockquote><p>Tip: 其实我们不使用 <code>drive</code> 也可以完成相应的功能，就像上面那样。这些操作符 Unit（不知道怎么翻译），其实属于 RxCocoa，并不是标准的 Rx 框架。但是通过使用这些 Unit，确实可以让我们编程更加方便。详情可以参考最后的参考链接。</p></blockquote><p>drive 源码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">drive</span>&lt;O: ObserverType where O.E == E&gt;<span class="params">(observer: O)</span></span> -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    <span class="type">MainScheduler</span>.ensureExecutingOnScheduler()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.asObservable().subscribe(observer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以看出，其实 <code>drive</code> 函数保证了之后的操作是在主线程的。下面列举了使用 Unit 的一些好处：</p><ul><li>不会发送错误 （错误会导致 dispose）</li><li>工作在主线程 （对于 UI 操作，不用再切换线程）</li><li>共享同一个值 （不用再使用 shareReplay）</li></ul><p>OK，现在我们已经完全过渡到终极版本了。Nice work！</p><p>我们现在回过头来看 <code>GeolocationService</code> 的 <code>init</code> 方法。</p><p>片段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">autorized = <span class="type">Observable</span>.deferred &#123; [<span class="keyword">weak</span> locationManager] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> status = <span class="type">CLLocationManager</span>.authorizationStatus() <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> locationManager = locationManager <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Observable</span>.just(status)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locationManager</span><br><span class="line">            .rx_didChangeAuthorizationStatus <span class="comment">// 2</span></span><br><span class="line">            .startWith(status) <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    .asDriver(onErrorJustReturn: <span class="type">CLAuthorizationStatus</span>.<span class="type">NotDetermined</span>) <span class="comment">// 4</span></span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">switch</span> $<span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">AuthorizedAlways</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取了一次地理位置授权状态</li><li>这里使用了 RxCocoa 的扩展，监听授权状态的变化（相比于 delegate 的方式，是不是爽多了）</li><li>将之前的 status 插入到序列的开头</li><li>将 Observable 转为 Observable，因为它使不回发送 error 的，所以这里要告诉它如果发生 error 直接发送 <code>.CLAuthorizationStatus.NotDetermined</code></li><li>最后将其 map 到 bool 类型</li></ol><p>OK，<code>location</code> 也是差不多的逻辑。你可以自己琢磨看看。</p><p>如果对 <code>Observable.deferred</code> 不是很理解，可以看看 <a href="https://github.com/futantan/RxSwiftCheatSheet#deferred" target="_blank" rel="noopener">这里</a></p><p>示例代码可以参见 RxSwiftExample，或者<a href="https://github.com/futantan/PrayerBlogCode" target="_blank" rel="noopener">这里</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Units.md" target="_blank" rel="noopener">https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Units.md</a><br><a href="http://t.swift.gg/d/39-021-units" target="_blank" rel="noopener">http://t.swift.gg/d/39-021-units</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里我们来从头实现 RxExample 的第三个例子：GeolocationExample。如果不知道如何开始，可以参考之前的几篇博文。&lt;/p&gt;
    
    </summary>
    
      <category term="Learn RxSwift The Hard Way" scheme="http://www.futantan.com/categories/Learn-RxSwift-The-Hard-Way/"/>
    
    
      <category term="iOS" scheme="http://www.futantan.com/tags/iOS/"/>
    
      <category term="RxSwift" scheme="http://www.futantan.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift 速查手册</title>
    <link href="http://www.futantan.com/2016/05/05/RxSwiftCheatSheet/"/>
    <id>http://www.futantan.com/2016/05/05/RxSwiftCheatSheet/</id>
    <published>2016-05-05T12:04:36.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文档内容来自于 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 的 Playground。记录大多数 ReactiveX 的概念和操作符。</p></blockquote><p><a href="https://github.com/futantan/RxSwiftCheatSheet" target="_blank" rel="noopener">GitHub 地址</a> </p><a id="more"></a><p>(部分翻译和注解来自 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Subject.html" target="_blank" rel="noopener">ReactiveX文档中文翻译</a>)</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="为什么使用-RxSwift"><a href="#为什么使用-RxSwift" class="headerlink" title="为什么使用 RxSwift?"></a>为什么使用 RxSwift?</h2><p>我们写的很多代码实际上是为了解决和响应外部事件。当用户操作一个控件的时候，我们需要使用 @IBAction 来响应事件。我们需要观察通知来检测键盘改变位置。当 URL Sessions 带着响应的数据返回时，我们需要提供闭包来执行我们的操作。我们还需要使用 KVO 来检测变量的值改变。这些大量的编写机制使得我们的代码结构变的更加复杂。如果有一种统一的编写机制来完成所有的这些调用/响应代码是不是更棒呢？Rx 就是为解决这些问题而生的。</p><h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>理解 RxSwift 的关键是理解 Observable 的概念。要理解它的创建，操作以及为了对变化做出响应操作而进行的订阅（subscribe）。</p><h2 id="创建和订阅-Observable"><a href="#创建和订阅-Observable" class="headerlink" title="创建和订阅 Observable"></a>创建和订阅 Observable</h2><p>要理解本框架，第一步需要理解如何创建 Observable。有很多函数可以创建 Observable。</p><p>创建 Observable 之后，如果没有订阅者订阅该 observable，那么什么事情也不会发生，所以我们将同时解释创建和订阅。</p><h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><p><code>empty</code> 创建一个空的序列。它仅发送 <code>.Completed</code> 消息。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"empty"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> emptySequence = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.empty()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscription = emptySequence</span><br><span class="line">        .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- empty example ---</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code> 创建一个序列，该序列永远不会发送消息，<code>.Completed</code> 消息也不会发送。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"never"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> neverSequence = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.never()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscription = neverSequence</span><br><span class="line">        .subscribe &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"This block is never called."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--- never example ---</span><br></pre></td></tr></table></figure></p><h3 id="just"><a href="#just" class="headerlink" title="just"></a>just</h3><p><code>just</code> 代表只包含一个元素的序列。它将向订阅者发送两个消息，第一个消息是其中元素的值，另一个是 <code>.Completed</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"just"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> singleElementSequence = <span class="type">Observable</span>.just(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscription = singleElementSequence</span><br><span class="line">        .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- just example ---</span><br><span class="line">Next(32)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="sequenceOf"><a href="#sequenceOf" class="headerlink" title="sequenceOf"></a>sequenceOf</h3><p><code>sequenceOf</code> 通过固定数目的元素创建一个序列</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"sequenceOf"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceOfElements<span class="comment">/* : Observable&lt;Int&gt; */</span> = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscription = sequenceOfElements</span><br><span class="line">        .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--- sequenceOf example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Next(4)</span><br><span class="line">Next(5)</span><br><span class="line">Next(6)</span><br><span class="line">Next(7)</span><br><span class="line">Next(8)</span><br><span class="line">Next(9)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="toObservable"><a href="#toObservable" class="headerlink" title="toObservable"></a>toObservable</h3><p><code>toObservable</code> 在一个数组的基础上创建一个序列</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"toObservable"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceFromArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].toObservable()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscription = sequenceFromArray</span><br><span class="line">        .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- toObservable example ---</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Next(4)</span><br><span class="line">Next(5)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p><code>create</code> 使用 Swift 闭包来创建一个序列。该例子中，创建了 <code>just</code> 操作符的自定义版本。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"create"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> myJust = &#123; (singleElement: <span class="type">Int</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>.create &#123; observer <span class="keyword">in</span></span><br><span class="line">            observer.on(.<span class="type">Next</span>(singleElement))</span><br><span class="line">            observer.on(.<span class="type">Completed</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">NopDisposable</span>.instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscription = myJust(<span class="number">5</span>)</span><br><span class="line">        .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- create example ---</span><br><span class="line">Next(5)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p><code>generate</code> 创建的序列可以自己生成它的值，并且在之前值的基础上来判断什么时候结束。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"generate"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> generated = <span class="type">Observable</span>.generate(</span><br><span class="line">        initialState: <span class="number">0</span>,</span><br><span class="line">        condition: &#123; $<span class="number">0</span> &lt; <span class="number">3</span> &#125;,</span><br><span class="line">        iterate: &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscription = generated</span><br><span class="line">        .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- generate example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>创建一个不发送任何 item 的 Observable，以 error 中指</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"error"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"Test"</span>, code: -<span class="number">1</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> erroredSequence = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.error(error)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscription = erroredSequence</span><br><span class="line">        .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- error example ---</span><br><span class="line">Error(Error Domain=Test Code=-1 &quot;(null)&quot;)</span><br></pre></td></tr></table></figure><h3 id="deferred"><a href="#deferred" class="headerlink" title="deferred"></a>deferred</h3><p>直到 observer 订阅之后才创建 Observable，并且为每一个 observer 创建一个全新的 Observable<br>do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/defer.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/defer.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"deferred"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> deferredSequence: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = <span class="type">Observable</span>.deferred &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"creating"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>.create &#123; observer <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"emmiting"</span>)</span><br><span class="line">            observer.on(.<span class="type">Next</span>(<span class="number">0</span>))</span><br><span class="line">            observer.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">            observer.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">NopDisposable</span>.instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = deferredSequence</span><br><span class="line">        .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = deferredSequence</span><br><span class="line">        .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--- deferred example ---</span><br><span class="line">creating</span><br><span class="line">emmiting</span><br><span class="line">Next(0)</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">creating</span><br><span class="line">emmiting</span><br><span class="line">Next(0)</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br></pre></td></tr></table></figure><p>在 RxCocoa 库中还有很多其他非常有用的方法，例如：</p><ul><li><code>rx_observe</code> 存在于所有 NSObject 子类中，封装了 KVO</li><li><code>rx_tap</code> 存在于 button 中，封装了 @IBActions</li><li><code>rx_notification</code> 封装了 NotificationCenter</li><li>…</li></ul><h1 id="Subjects"><a href="#Subjects" class="headerlink" title="Subjects"></a>Subjects</h1><p>Subject 可以看成是一个桥梁或者代理，在某些ReactiveX实现中，它同时充当了 Observer 和 Observable 的角色。因为它是一个Observer，它可以订阅一个或多个 Observable；又因为它是一个 Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。</p><p>辅助函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeSequenceToConsole</span>&lt;O: ObservableType&gt;<span class="params">(name: String, sequence: O)</span></span> -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sequence</span><br><span class="line">        .subscribe &#123; e <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Subscription: \(name), event: \(e)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h2><p><code>PublishSubject</code> 只会把在订阅发生的时间点之后来自原始Observable的数据发射给观察者。</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/publishsubject.png" alt=""></p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/publishsubject_error.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"PublishSubject"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: subject).addDisposableTo(disposeBag)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"a"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"b"</span>))</span><br><span class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: subject).addDisposableTo(disposeBag)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"c"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"d"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- PublishSubject example ---</span><br><span class="line">Subscription: 1, event: Next(a)</span><br><span class="line">Subscription: 1, event: Next(b)</span><br><span class="line">Subscription: 1, event: Next(c)</span><br><span class="line">Subscription: 2, event: Next(c)</span><br><span class="line">Subscription: 1, event: Next(d)</span><br><span class="line">Subscription: 2, event: Next(d)</span><br></pre></td></tr></table></figure><h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p><code>ReplaySubject</code> 会发射所有来自原始Observable的数据给观察者，无论它们是何时订阅的。当一个新的 observer 订阅了一个 <code>ReplaySubject</code> 之后，他将会收到当前缓存在 buffer 中的数据和这之后产生的新数据。在下面的例子中，缓存大小为 <code>1</code> 所以 observer 将最多能够收到订阅时间点之前的一个数据。例如，<code>Subscription: 2</code> 能够收到消息 <code>&quot;b&quot;</code>，而这个消息是在他订阅之前发送的，但是没有办法收到消息 <code>&quot;a&quot;</code> 因为缓存的容量小于 <code>2</code>。</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/replaysubject.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"ReplaySubject"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: subject).addDisposableTo(disposeBag)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"a"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"b"</span>))</span><br><span class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: subject).addDisposableTo(disposeBag)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"c"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"d"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- ReplaySubject example ---  </span><br><span class="line">Subscription: 1, event: Next(a)  </span><br><span class="line">Subscription: 1, event: Next(b)  </span><br><span class="line">Subscription: 2, event: Next(b)  </span><br><span class="line">Subscription: 1, event: Next(c)  </span><br><span class="line">Subscription: 2, event: Next(c)  </span><br><span class="line">Subscription: 1, event: Next(d)  </span><br><span class="line">Subscription: 2, event: Next(d)</span><br></pre></td></tr></table></figure><h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>当观察者订阅 <code>BehaviorSubject</code> 时，它开始发射原始 Observable 最近发射的数据（如果此时还没有收到任何数据，它会发射一个默认值），然后继续发射其它任何来自原始Observable的数据。 </p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/behaviorsubject.png" alt=""></p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/behaviorsubject_error.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"BehaviorSubject"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="string">"z"</span>)</span><br><span class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: subject).addDisposableTo(disposeBag)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"a"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"b"</span>))</span><br><span class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: subject).addDisposableTo(disposeBag)</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"c"</span>))</span><br><span class="line">    subject.on(.<span class="type">Next</span>(<span class="string">"d"</span>))</span><br><span class="line">    subject.on(.<span class="type">Completed</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--- BehaviorSubject example ---</span><br><span class="line">Subscription: 1, event: Next(z)</span><br><span class="line">Subscription: 1, event: Next(a)</span><br><span class="line">Subscription: 1, event: Next(b)</span><br><span class="line">Subscription: 2, event: Next(b)</span><br><span class="line">Subscription: 1, event: Next(c)</span><br><span class="line">Subscription: 2, event: Next(c)</span><br><span class="line">Subscription: 1, event: Next(d)</span><br><span class="line">Subscription: 2, event: Next(d)</span><br><span class="line">Subscription: 1, event: Completed</span><br><span class="line">Subscription: 2, event: Completed</span><br></pre></td></tr></table></figure><h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p><code>Variable</code> 封装了 <code>BehaviorSubject</code>。使用 variable 的好处是 variable 将不会显式的发送 <code>Error</code> 或者 <code>Completed</code>。在 deallocated 的时候，<code>Variable</code> 会自动的发送 complete 事件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"Variable"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="keyword">let</span> variable = <span class="type">Variable</span>(<span class="string">"z"</span>)</span><br><span class="line">    writeSequenceToConsole(<span class="string">"1"</span>, sequence: variable.asObservable()).addDisposableTo(disposeBag)</span><br><span class="line">    variable.value = <span class="string">"a"</span></span><br><span class="line">    variable.value = <span class="string">"b"</span></span><br><span class="line">    writeSequenceToConsole(<span class="string">"2"</span>, sequence: variable.asObservable()).addDisposableTo(disposeBag)</span><br><span class="line">    variable.value = <span class="string">"c"</span></span><br><span class="line">    variable.value = <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--- Variable example ---</span><br><span class="line">Subscription: 1, event: Next(z)</span><br><span class="line">Subscription: 1, event: Next(a)</span><br><span class="line">Subscription: 1, event: Next(b)</span><br><span class="line">Subscription: 2, event: Next(b)</span><br><span class="line">Subscription: 1, event: Next(c)</span><br><span class="line">Subscription: 2, event: Next(c)</span><br><span class="line">Subscription: 1, event: Next(d)</span><br><span class="line">Subscription: 2, event: Next(d)</span><br><span class="line">Subscription: 1, event: Completed</span><br><span class="line">Subscription: 2, event: Completed</span><br></pre></td></tr></table></figure><h2 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h2><p>下面列出了可用于对 Observable 发射的数据执行变换操作的各种操作符。</p><h3 id="map-select"><a href="#map-select" class="headerlink" title="map / select"></a><code>map</code> / <code>select</code></h3><p>对序列的每一项都应用一个函数来变换 Observable 发射的数据序列</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/map.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/map.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"map"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> originalSequence = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = originalSequence</span><br><span class="line">        .<span class="built_in">map</span> &#123; number <span class="keyword">in</span></span><br><span class="line">            number * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- map example ---</span><br><span class="line">Next(2)</span><br><span class="line">Next(4)</span><br><span class="line">Next(6)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><code>flatMap</code></h3><p>将每个 Obserable 发射的数据变换为 Observable 的集合，然后将其 “拍扁”（降维 flatten）成一个 Observable。</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/flatmap.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"flatMap"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceInt = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sequenceString = <span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"--"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = sequenceInt</span><br><span class="line">        .flatMap &#123; (x:<span class="type">Int</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"from sequenceInt \(x)"</span>)</span><br><span class="line">            <span class="keyword">return</span> sequenceString</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--- flatMap example ---</span><br><span class="line">from sequenceInt 1</span><br><span class="line">Next(A)</span><br><span class="line">Next(B)</span><br><span class="line">Next(C)</span><br><span class="line">Next(D)</span><br><span class="line">Next(E)</span><br><span class="line">Next(F)</span><br><span class="line">Next(--)</span><br><span class="line">from sequenceInt 2</span><br><span class="line">Next(A)</span><br><span class="line">Next(B)</span><br><span class="line">Next(C)</span><br><span class="line">Next(D)</span><br><span class="line">Next(E)</span><br><span class="line">Next(F)</span><br><span class="line">Next(--)</span><br><span class="line">from sequenceInt 3</span><br><span class="line">Next(A)</span><br><span class="line">Next(B)</span><br><span class="line">Next(C)</span><br><span class="line">Next(D)</span><br><span class="line">Next(E)</span><br><span class="line">Next(F)</span><br><span class="line">Next(--)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a><code>scan</code></h3><p>对 Observable 发射的每一项数据应用一个函数，然后按顺序依次发射每一个值</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/scan.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/scan.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"scan"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceToSum = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = sequenceToSum</span><br><span class="line">        .scan(<span class="number">0</span>) &#123; acum, elem <span class="keyword">in</span></span><br><span class="line">            acum + elem</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- scan example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(1)</span><br><span class="line">Next(3)</span><br><span class="line">Next(6)</span><br><span class="line">Next(10)</span><br><span class="line">Next(15)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><p>从源 Observable 中选择特定的数据发送</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a><code>filter</code></h3><p>只发送 Observable 中通过特定测试的数据</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/filter.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/filter.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"filter"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subscription = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">        .<span class="built_in">filter</span> &#123;</span><br><span class="line">            $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- filter example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(2)</span><br><span class="line">Next(4)</span><br><span class="line">Next(6)</span><br><span class="line">Next(8)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a><code>distinctUntilChanged</code></h3><p>过滤掉连续重复的数据</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/distinct.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/distinct.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"distinctUntilChanged"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subscription = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        .distinctUntilChanged()</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- distinctUntilChanged example ---</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Next(1)</span><br><span class="line">Next(4)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="take"><a href="#take" class="headerlink" title="take"></a><code>take</code></h3><p>仅发送 Observable 的前 n 个数据项</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/take.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/take.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example(&quot;take&quot;) &#123;</span><br><span class="line">    let subscription = Observable.of(1, 2, 3, 4, 5, 6)</span><br><span class="line">        .take(3)</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            print($0)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- take example ---</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h2 id="结合操作-Combination-operators"><a href="#结合操作-Combination-operators" class="headerlink" title="结合操作(Combination operators)"></a>结合操作(Combination operators)</h2><p>将多个 Observable 结合成一个 Observable</p><h3 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a><code>startWith</code></h3><p>在数据序列的开头增加一些数据</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/startwith.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/startwith.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"startWith"</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscription = <span class="type">Observable</span>.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">        .startWith(<span class="number">3</span>)</span><br><span class="line">        .startWith(<span class="number">2</span>)</span><br><span class="line">        .startWith(<span class="number">1</span>)</span><br><span class="line">        .startWith(<span class="number">0</span>)</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--- startWith example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Next(4)</span><br><span class="line">Next(5)</span><br><span class="line">Next(6)</span><br><span class="line">Next(7)</span><br><span class="line">Next(8)</span><br><span class="line">Next(9)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a><code>combineLatest</code></h3><p>当两个 Observables 中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/combinelatest.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/combinelatest.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"combineLatest 1"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> intOb1 = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> intOb2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>.combineLatest(intOb1, intOb2) &#123;</span><br><span class="line">        <span class="string">"\($0) \($1)"</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"A"</span>))</span><br><span class="line"></span><br><span class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"B"</span>))</span><br><span class="line"></span><br><span class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- combineLatest 1 example ---</span><br><span class="line">Next(A 1)</span><br><span class="line">Next(B 1)</span><br><span class="line">Next(B 2)</span><br></pre></td></tr></table></figure><p>为了能够产生结果，两个序列中都必须保证至少有一个元素</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"combineLatest 2"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> intOb1 = <span class="type">Observable</span>.just(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> intOb2 = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>.combineLatest(intOb1, intOb2) &#123;</span><br><span class="line">            $<span class="number">0</span> * $<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- combineLatest 2 example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(2)</span><br><span class="line">Next(4)</span><br><span class="line">Next(6)</span><br><span class="line">Next(8)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><p>Combine latest 有超过 2 个参数的版本</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"combineLatest 3"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> intOb1 = <span class="type">Observable</span>.just(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> intOb2 = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">let</span> intOb3 = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>.combineLatest(intOb1, intOb2, intOb3) &#123;</span><br><span class="line">            ($<span class="number">0</span> + $<span class="number">1</span>) * $<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- combineLatest 3 example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(5)</span><br><span class="line">Next(10)</span><br><span class="line">Next(15)</span><br><span class="line">Next(20)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><p>Combinelatest 可以作用于不同数据类型的序列</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"combineLatest 4"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> intOb = <span class="type">Observable</span>.just(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> stringOb = <span class="type">Observable</span>.just(<span class="string">"a"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>.combineLatest(intOb, stringOb) &#123;</span><br><span class="line">            <span class="string">"\($0) "</span> + $<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- combineLatest 4 example ---</span><br><span class="line">Next(2 a)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><p><code>combineLatest</code> 方法可以在 Array 上使用，数组元素类型必须遵循 <code>ObservableType</code> 协议<br>数组中的元素类型必须为 <code>Observables</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"combineLatest 5"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> intOb1 = <span class="type">Observable</span>.just(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> intOb2 = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">let</span> intOb3 = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="number">_</span> = [intOb1, intOb2, intOb3].combineLatest &#123; intArray -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">Int</span>((intArray[<span class="number">0</span>] + intArray[<span class="number">1</span>]) * intArray[<span class="number">2</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123; (event: <span class="type">Event</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a><code>zip</code></h3><p>使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果(从序列中依次取数据)</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/zip.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/zip.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"zip 1"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> intOb1 = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> intOb2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>.<span class="built_in">zip</span>(intOb1, intOb2) &#123;</span><br><span class="line">        <span class="string">"\($0) \($1)"</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"A"</span>))</span><br><span class="line"></span><br><span class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"B"</span>))</span><br><span class="line"></span><br><span class="line">    intOb1.on(.<span class="type">Next</span>(<span class="string">"C"</span>))</span><br><span class="line"></span><br><span class="line">    intOb2.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- zip 1 example ---</span><br><span class="line">Next(A 1)</span><br><span class="line">Next(B 2)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"zip 2"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> intOb1 = <span class="type">Observable</span>.just(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> intOb2 = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>.<span class="built_in">zip</span>(intOb1, intOb2) &#123;</span><br><span class="line">            $<span class="number">0</span> * $<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- zip 2 example ---</span><br><span class="line">Next(0)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"zip 3"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> intOb1 = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> intOb2 = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">let</span> intOb3 = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>.<span class="built_in">zip</span>(intOb1, intOb2, intOb3) &#123;</span><br><span class="line">            ($<span class="number">0</span> + $<span class="number">1</span>) * $<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- zip 3 example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(2)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a><code>merge</code></h3><p>合并多个 Observables 的组合成一个</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/merge.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/merge.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"merge 1"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subject1 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> subject2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>.of(subject1, subject2)</span><br><span class="line">        .merge()</span><br><span class="line">        .subscribeNext &#123; int <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(int)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">20</span>))</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">40</span>))</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">60</span>))</span><br><span class="line">    subject2.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">80</span>))</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">100</span>))</span><br><span class="line">    subject2.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- merge 1 example ---</span><br><span class="line">20</span><br><span class="line">40</span><br><span class="line">60</span><br><span class="line">1</span><br><span class="line">80</span><br><span class="line">100</span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"merge 2"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subject1 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> subject2 = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>.of(subject1, subject2)</span><br><span class="line">        .merge(maxConcurrent: <span class="number">2</span>)</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">20</span>))</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">40</span>))</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">60</span>))</span><br><span class="line">    subject2.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">80</span>))</span><br><span class="line">    subject1.on(.<span class="type">Next</span>(<span class="number">100</span>))</span><br><span class="line">    subject2.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- merge 2 example ---</span><br><span class="line">Next(20)</span><br><span class="line">Next(40)</span><br><span class="line">Next(60)</span><br><span class="line">Next(1)</span><br><span class="line">Next(80)</span><br><span class="line">Next(100)</span><br><span class="line">Next(1)</span><br></pre></td></tr></table></figure><h3 id="switchLatest"><a href="#switchLatest" class="headerlink" title="switchLatest"></a><code>switchLatest</code></h3><p>将一个发射多个 Observables 的 Observable 转换成另一个单独的 Observable，后者发射那些 Observables 最近发射的数据项</p><p>Switch 订阅一个发射多个 Observables 的 Observable。它每次观察那些 Observables 中的一个，Switch 返回的这个Observable取消订阅前一个发射数据的 Observable，开始发射最近的Observable 发射的数据。注意：当原始 Observable 发射了一个新的 Observable 时（不是这个新的 Observable 发射了一条数据时），它将取消订阅之前的那个 Observable。这意味着，在后来那个 Observable 产生之后到它开始发射数据之前的这段时间里，前一个 Observable 发射的数据将被丢弃</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/switch.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/switch.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"switchLatest"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> var1 = <span class="type">Variable</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> var2 = <span class="type">Variable</span>(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// var3 is like an Observable&lt;Observable&lt;Int&gt;&gt;</span></span><br><span class="line">    <span class="keyword">let</span> var3 = <span class="type">Variable</span>(var1.asObservable())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> d = var3</span><br><span class="line">        .asObservable()</span><br><span class="line">        .switchLatest()</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    var1.value = <span class="number">1</span></span><br><span class="line">    var1.value = <span class="number">2</span></span><br><span class="line">    var1.value = <span class="number">3</span></span><br><span class="line">    var1.value = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    var3.value = var2.asObservable()</span><br><span class="line"></span><br><span class="line">    var2.value = <span class="number">201</span></span><br><span class="line"></span><br><span class="line">    var1.value = <span class="number">5</span></span><br><span class="line">    var1.value = <span class="number">6</span></span><br><span class="line">    var1.value = <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--- switchLatest example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Next(4)</span><br><span class="line">Next(200)</span><br><span class="line">Next(201)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h2 id="Error-Handling-Operators"><a href="#Error-Handling-Operators" class="headerlink" title="Error Handling Operators"></a>Error Handling Operators</h2><p>下面的操作符帮助我们从 Observable 发射的 error 通知做出响应或者从错误中恢复。</p><h3 id="catchError"><a href="#catchError" class="headerlink" title="catchError"></a><code>catchError</code></h3><p>收到 <code>Error</code> 通知之后，转而发送一个没有错误的序列。</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/catch.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/catch.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"catchError 1"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceThatFails = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> recoverySequence = <span class="type">Observable</span>.of(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = sequenceThatFails</span><br><span class="line">        .catchError &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> recoverySequence</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    sequenceThatFails.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    sequenceThatFails.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">    sequenceThatFails.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">    sequenceThatFails.on(.<span class="type">Next</span>(<span class="number">4</span>))</span><br><span class="line">    sequenceThatFails.on(.<span class="type">Error</span>(<span class="type">NSError</span>(domain: <span class="string">"Test"</span>, code: <span class="number">0</span>, userInfo: <span class="literal">nil</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--- catchError 1 example ---</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Next(4)</span><br><span class="line">Next(100)</span><br><span class="line">Next(200)</span><br><span class="line">Next(300)</span><br><span class="line">Next(400)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"catchError 2"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceThatFails = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = sequenceThatFails</span><br><span class="line">        .catchErrorJustReturn(<span class="number">100</span>)</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    sequenceThatFails.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    sequenceThatFails.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">    sequenceThatFails.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">    sequenceThatFails.on(.<span class="type">Next</span>(<span class="number">4</span>))</span><br><span class="line">    sequenceThatFails.on(.<span class="type">Error</span>(<span class="type">NSError</span>(domain: <span class="string">"Test"</span>, code: <span class="number">0</span>, userInfo: <span class="literal">nil</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- catchError 2 example ---</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Next(4)</span><br><span class="line">Next(100)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="retry"><a href="#retry" class="headerlink" title="retry"></a><code>retry</code></h3><p>如果原始 Observable 遇到错误，重新订阅，心里默念，不会出错不会出错…</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/retry.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/retry.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"retry"</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span> <span class="comment">// bad practice, only for example purposes</span></span><br><span class="line">    <span class="keyword">let</span> funnyLookingSequence = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"Test"</span>, code: <span class="number">0</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        observer.on(.<span class="type">Next</span>(<span class="number">0</span>))</span><br><span class="line">        observer.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">        observer.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> &lt; <span class="number">2</span> &#123;</span><br><span class="line">            observer.on(.<span class="type">Error</span>(error))</span><br><span class="line">            <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        observer.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">        observer.on(.<span class="type">Next</span>(<span class="number">4</span>))</span><br><span class="line">        observer.on(.<span class="type">Next</span>(<span class="number">5</span>))</span><br><span class="line">        observer.on(.<span class="type">Completed</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">NopDisposable</span>.instance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = funnyLookingSequence</span><br><span class="line">        .retry()</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--- retry example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(0)</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Next(4)</span><br><span class="line">Next(5)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h2 id="Observable-Utility-Operators"><a href="#Observable-Utility-Operators" class="headerlink" title="Observable Utility Operators"></a>Observable Utility Operators</h2><p>下面的操作符可以当做一个工具集，方便操作 Observable</p><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a><code>subscribe</code></h3><p><a href="http://reactivex.io/documentation/operators/subscribe.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"subscribe"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = sequenceOfInts</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    sequenceOfInts.on(.<span class="type">Completed</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- subscribe example ---</span><br><span class="line">Next(1)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><p>下面是几个 <code>subscribe</code> 操作符的变体</p><h3 id="subscribeNext"><a href="#subscribeNext" class="headerlink" title="subscribeNext"></a><code>subscribeNext</code></h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"subscribeNext"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = sequenceOfInts</span><br><span class="line">        .subscribeNext &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    sequenceOfInts.on(.<span class="type">Completed</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- subscribeNext example ---</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="subscribeCompleted"><a href="#subscribeCompleted" class="headerlink" title="subscribeCompleted"></a><code>subscribeCompleted</code></h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"subscribeCompleted"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = sequenceOfInts</span><br><span class="line">        .subscribeCompleted &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"It's completed"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    sequenceOfInts.on(.<span class="type">Completed</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- subscribeCompleted example ---</span><br><span class="line">It&apos;s completed</span><br></pre></td></tr></table></figure><h3 id="subscribeError"><a href="#subscribeError" class="headerlink" title="subscribeError"></a><code>subscribeError</code></h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"subscribeError"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = sequenceOfInts</span><br><span class="line">        .subscribeError &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    sequenceOfInts.on(.<span class="type">Error</span>(<span class="type">NSError</span>(domain: <span class="string">"Examples"</span>, code: -<span class="number">1</span>, userInfo: <span class="literal">nil</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- subscribeError example ---</span><br><span class="line">Error Domain=Examples Code=-1 &quot;(null)&quot;</span><br></pre></td></tr></table></figure><h3 id="doOn"><a href="#doOn" class="headerlink" title="doOn"></a><code>doOn</code></h3><p>注册一个操作来监听事件的生命周期<br>（register an action to take upon a variety of Observable lifecycle events）</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/do.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/do.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"doOn"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sequenceOfInts = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = sequenceOfInts</span><br><span class="line">        .doOn &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Intercepted event \($0)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    sequenceOfInts.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    sequenceOfInts.on(.<span class="type">Completed</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- doOn example ---</span><br><span class="line">Intercepted event Next(1)</span><br><span class="line">Next(1)</span><br><span class="line">Intercepted event Completed</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h2 id="条件和布尔操作（Conditional-and-Boolean-Operators）"><a href="#条件和布尔操作（Conditional-and-Boolean-Operators）" class="headerlink" title="条件和布尔操作（Conditional and Boolean Operators）"></a>条件和布尔操作（Conditional and Boolean Operators）</h2><p>下面的操作符可用于根据条件发射或变换 Observables，或者对它们做布尔运算：</p><h3 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a><code>takeUntil</code></h3><p>当第二个 Observable 发送数据之后，丢弃第一个 Observable 在这之后的所有消息。</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/takeuntil.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/takeuntil.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"takeUntil"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> originalSequence = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> whenThisSendsNextWorldStops = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = originalSequence</span><br><span class="line">        .takeUntil(whenThisSendsNextWorldStops)</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    whenThisSendsNextWorldStops.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    originalSequence.on(.<span class="type">Next</span>(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--- takeUntil example ---</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Next(4)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h3 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a><code>takeWhile</code></h3><p>发送原始 Observable 的数据，直到一个特定的条件为 false</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/takewhile.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/takewhile.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"takeWhile"</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sequence = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = sequence</span><br><span class="line">        .takeWhile &#123; int <span class="keyword">in</span></span><br><span class="line">            int &lt; <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">4</span>))</span><br><span class="line">    sequence.on(.<span class="type">Next</span>(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- takeWhile example ---</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure><h2 id="算数和聚合-Mathematical-and-Aggregate-Operators"><a href="#算数和聚合-Mathematical-and-Aggregate-Operators" class="headerlink" title="算数和聚合(Mathematical and Aggregate Operators)"></a>算数和聚合(Mathematical and Aggregate Operators)</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a><code>concat</code></h3><p>合并两个或者以上的 Observable 的消息，并且这些消息的发送时间不会交叉。（队列先后顺序不会交叉）</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/concat.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/concat.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"concat"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> var1 = <span class="type">BehaviorSubject</span>(value: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> var2 = <span class="type">BehaviorSubject</span>(value: <span class="number">200</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// var3 is like an Observable&lt;Observable&lt;Int&gt;&gt;</span></span><br><span class="line">    <span class="keyword">let</span> var3 = <span class="type">BehaviorSubject</span>(value: var1)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> d = var3</span><br><span class="line">        .concat()</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    var1.on(.<span class="type">Next</span>(<span class="number">1</span>))</span><br><span class="line">    var1.on(.<span class="type">Next</span>(<span class="number">2</span>))</span><br><span class="line">    var1.on(.<span class="type">Next</span>(<span class="number">3</span>))</span><br><span class="line">    var1.on(.<span class="type">Next</span>(<span class="number">4</span>))</span><br><span class="line">    </span><br><span class="line">    var3.on(.<span class="type">Next</span>(var2))</span><br><span class="line">    </span><br><span class="line">    var2.on(.<span class="type">Next</span>(<span class="number">201</span>))</span><br><span class="line">    </span><br><span class="line">    var1.on(.<span class="type">Next</span>(<span class="number">5</span>))</span><br><span class="line">    var1.on(.<span class="type">Next</span>(<span class="number">6</span>))</span><br><span class="line">    var1.on(.<span class="type">Next</span>(<span class="number">7</span>))</span><br><span class="line">    var1.on(.<span class="type">Completed</span>)</span><br><span class="line">    </span><br><span class="line">    var2.on(.<span class="type">Next</span>(<span class="number">202</span>))</span><br><span class="line">    var2.on(.<span class="type">Next</span>(<span class="number">203</span>))</span><br><span class="line">    var2.on(.<span class="type">Next</span>(<span class="number">204</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--- concat example ---</span><br><span class="line">Next(0)</span><br><span class="line">Next(1)</span><br><span class="line">Next(2)</span><br><span class="line">Next(3)</span><br><span class="line">Next(4)</span><br><span class="line">Next(5)</span><br><span class="line">Next(6)</span><br><span class="line">Next(7)</span><br><span class="line">Next(201)</span><br><span class="line">Next(202)</span><br><span class="line">Next(203)</span><br><span class="line">Next(204)</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><code>reduce</code></h3><p>按顺序对Observable发射的每项数据应用一个函数并发射最终的值。<br><code>Reduce</code> 操作符对原始 Observable 发射数据的第一项应用一个函数，然后再将这个函数的返回值与第二项数据一起传递给函数，以此类推，持续这个过程知道原始Observable发射它的最后一项数据并终止，此时 Reduce 返回的 Observable 发射这个函数返回的最终值。与数组序列的 <code>reduce</code> 操作类似。</p><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/master/MarbleDiagrams/png/reduce.png" alt=""></p><p><a href="http://reactivex.io/documentation/operators/reduce.html" target="_blank" rel="noopener">更多相关内容请查看 reactive.io</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example(<span class="string">"reduce"</span>) &#123;</span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">        .<span class="built_in">reduce</span>(<span class="number">0</span>, accumulator: +)</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- reduce example ---</span><br><span class="line">Next(45)</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文档内容来自于 &lt;a href=&quot;https://github.com/ReactiveX/RxSwift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RxSwift&lt;/a&gt; 的 Playground。记录大多数 ReactiveX 的概念和操作符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/futantan/RxSwiftCheatSheet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 地址&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="RxSwift" scheme="http://www.futantan.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>Learn RxSwift The Hard Way - Calculator (二)</title>
    <link href="http://www.futantan.com/2016/05/03/Learn-RxSwift-The-Hard-Way-Calculator/"/>
    <id>http://www.futantan.com/2016/05/03/Learn-RxSwift-The-Hard-Way-Calculator/</id>
    <published>2016-05-03T14:56:36.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>To RxSwift:<br>初次见面，请多关照。</p><a id="more"></a><p>Demo 的 GitHub 地址：<a href="https://github.com/futantan/PrayerBlogCode/tree/master/RxSwiftDemo" target="_blank" rel="noopener">RxSwiftDemo</a></p><p>这里我们将实现 RxSwift Demo 中最简单的一个例子，加法器。</p><p><img src="/media/14622874699158.jpg" width="400"></p><p>如图所示，有三个 UITextField，代表着三个输入的数字，最后是一个显示结果的 Label。这里的逻辑很简单，就不给大家展示代码了。</p><p>主要的逻辑代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>.combineLatest(number1.rx_text, number2.rx_text, number3.rx_text) &#123;</span><br><span class="line">  (textValue1, textValue2, textValue3) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">Int</span>(textValue1) ?? <span class="number">0</span>) + (<span class="type">Int</span>(textValue2) ?? <span class="number">0</span>) + (<span class="type">Int</span>(textValue3) ?? <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">.<span class="built_in">map</span> &#123; $<span class="number">0</span>.description &#125;</span><br><span class="line">.bindTo(result.rx_text)</span><br><span class="line">.addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure><p>其中，<code>combineLatest</code> 的效果可以从 <a href="http://rxmarbles.com/#combineLatest" target="_blank" rel="noopener">http://rxmarbles.com/#combineLatest</a> 这里很直观的看到。这里是将三个被加数的值进行计算，返回它们的和。<code>map</code> 将 Int 值转为 String，<code>bindTo</code> 将 String 值赋给了 result label。最后 <code>addDisposableTo</code> 是内存管理的东西，我们以后再谈。</p><p>从我们的第一个 Demo 中，就可以看出 RxSwift 的强大之处了。如果我们使用 Cocoa 的方式来实现，需要这监听这三个 TextField 的值变化，设置代理，然后进行计算，想想都头大。这里的代码简洁明了，爽！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;To RxSwift:&lt;br&gt;初次见面，请多关照。&lt;/p&gt;
    
    </summary>
    
      <category term="Learn RxSwift The Hard Way" scheme="http://www.futantan.com/categories/Learn-RxSwift-The-Hard-Way/"/>
    
    
      <category term="iOS" scheme="http://www.futantan.com/tags/iOS/"/>
    
      <category term="RxSwift" scheme="http://www.futantan.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>Learn RxSwift The Hard Way - Introduction (一)</title>
    <link href="http://www.futantan.com/2016/05/03/Learn-RxSwift-The-Hard-Way-Introduction/"/>
    <id>http://www.futantan.com/2016/05/03/Learn-RxSwift-The-Hard-Way-Introduction/</id>
    <published>2016-05-03T14:15:52.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7qnang.com1.z0.glb.clouddn.com/16-5-3/38541829.jpg" alt=""><br>从这篇博文开始，我准备开一个新的坑，来记录一下学习 RxSwift 的过程。</p><a id="more"></a><h2 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h2><p>RxSwift 和 ReactiveCocoa 很类似，是一个函数式响应式编程（Functional Reactive Programming）框架，<a href="https://www.raywenderlich.com/126522/reactivecocoa-vs-rxswift" target="_blank" rel="noopener">Ray</a> 出了一篇比较两个框架的文章，如果你不知道该如何选取，可以看看这一篇文章。我选择的原因也很简单，我想使用纯 Swift 😂</p><h2 id="阅读-Documents"><a href="#阅读-Documents" class="headerlink" title="阅读 Documents"></a>阅读 Documents</h2><p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>的 README 文档中有一些简短的介绍，包括其中的链接，都通读一遍，大概对 RxSwift 有了一个大致的了解。</p><p>后面 clone 了 RxSwift 的代码，将其中的 playground 跑一遍，熟悉一下常用的操作符，<br><img src="http://7qnang.com1.z0.glb.clouddn.com/16-5-3/48780598.jpg" alt=""> 我在  <a href="https://github.com/futantan/RxSwiftCheatSheet" target="_blank" rel="noopener">GitHub</a> 上创建了一个 repo，将会记录一下常用的操作符及其作用（虽然 playground 跑过了，但是用的时候还是想要查看一下用法，可能刚入门还是不太熟悉吧）</p><p>目前 RxSwift 的中文文档和示例代码什么的还不是很健全，我打算使用最笨的方式，读 RxSwift Example 源码，并且自己重写一遍来学习。所以接下来的几篇博客会记录我在重写过程中遇到的问题和解决办法。</p><p>Happy Hacking!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7qnang.com1.z0.glb.clouddn.com/16-5-3/38541829.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;从这篇博文开始，我准备开一个新的坑，来记录一下学习 RxSwift 的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Learn RxSwift The Hard Way" scheme="http://www.futantan.com/categories/Learn-RxSwift-The-Hard-Way/"/>
    
    
      <category term="iOS" scheme="http://www.futantan.com/tags/iOS/"/>
    
      <category term="RxSwift" scheme="http://www.futantan.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>NSTimer 使用锦囊</title>
    <link href="http://www.futantan.com/2016/04/14/NSTimer-tips/"/>
    <id>http://www.futantan.com/2016/04/14/NSTimer-tips/</id>
    <published>2016-04-14T01:36:05.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/14605987599888.jpg" alt=""><br>来看看你是否被 NSTimer 坑过吧 ^_^</p><a id="more"></a><p>完整的示例代码可以可以从 <a href="https://github.com/futantan/PrayerBlogCode" target="_blank" rel="noopener">这里</a> 获得。</p><p>新建一个工程，再添加一个 VC，SecondViewController 效果图如下：<br><img src="/media/14605514256732-1.jpg" alt="14605514256732"></p><p>可以观察到，最左边，为了方便控制器间的跳转，我们将其嵌入 Navigation Controller 中。第一个 VC 中有一个按钮，<code>next VC</code> 点击之后，会跳转到下一个控制器中；第二个控制器中添加了两个按钮，完整的代码逻辑如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> timer: <span class="type">NSTimer</span>?</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in deinit"</span>)</span><br><span class="line">    timer?.invalidate()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">onFireButtonClicked</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    timer = <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">2</span>, target: <span class="keyword">self</span>, selector: #selector(sayHello), userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(timer: NSTimer)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="built_in">print</span>(timer)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">onInvalidateButtonClicked</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    timer?.invalidate()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li>timer 是 weak 的</li><li>swift 2.2 中 #selector 的用法</li><li>selector 的函数，也就是 sayHello 是可以接收参数的</li></ol><p>我们来分别讨论。</p><p>对于第一点，NSTimer 的官方文档有如下说明</p><blockquote><p>Timers work in conjunction with run loops. To use a timer effectively, you should be aware of how run loops operate—see NSRunLoop and Threading Programming Guide. Note in particular that run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop.</p></blockquote><p>注意，这里说 run loops 将会对 timer 持有强引用，所以我们不需要也不应该在代码中对 timer 使用强引用。</p><p>引用的示意图如下</p><p><img src="/media/14605527787801.jpg" alt=""></p><p>第二点是 swift 2.2 的更新，终于不怕写错函数名了。你可以<a href="http://swifter.tips/selector/" target="_blank" rel="noopener">从这里</a>了解更多。</p><p>关于第三点，官方文档是这么说的：</p><blockquote><p>The selector should have the following signature: timerFireMethod: (including a colon to indicate that the method takes an argument). The timer passes itself as the argument, thus the method would adopt the following pattern:<br><code>- (void)timerFireMethod:(NSTimer *)timer</code></p></blockquote><p>So far so good!</p><p>但是，大家试试点击 <code>fire</code> 按钮，然后直接用右滑返回手势将 VC 移出，会发现，控制台不停的在输出，VC 的<code>deinit</code>方法并没有调用，我们的 timer 并没有停止！</p><p>原因也是显而易见的，因为 Timer 没有被停止，而 Timer 因为 target action 的关系，有拥有 VC 的强引用，所以一直 VC 一直得不到释放，除非我们手动调用 invalidate 方法。</p><p>为了让 Timer 不持有 VC 的强引用，我们使用一个闭包来替代 target action 的方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSTimer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">scheduledTimerWithTimeInterval</span>(<span class="title">timeInterval</span>: <span class="title">NSTimeInterval</span>, <span class="title">repeats</span>: <span class="title">Bool</span> = <span class="title">false</span>, <span class="title">block</span>: () -&gt; ()) -&gt; <span class="title">NSTimer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scheduledTimerWithTimeInterval(timeInterval,</span><br><span class="line">                                          target: <span class="keyword">self</span>,</span><br><span class="line">                                          selector: #selector(_executeBlockFromTimer),</span><br><span class="line">                                          userInfo: block,</span><br><span class="line">                                          repeats: repeats)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">func</span> _executeBlockFromTimer(<span class="title">timer</span>: <span class="title">NSTimer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// execute block</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里出现一个问题，<br><img src="/media/14605550546067.jpg" alt=""></p><p>在 <a href="http://stackoverflow.com/questions/28211973/swift-closure-as-anyobject" target="_blank" rel="noopener">SOF</a> 上有个解决办法，加个中间层，修改后的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSTimer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FTTimerClosureWraper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> (<span class="keyword">set</span>) <span class="keyword">var</span> timerClosure: () -&gt; ()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(timerClosure: () -&gt; () ) &#123;</span><br><span class="line">      <span class="keyword">self</span>.timerClosure = timerClosure</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">scheduledTimerWithTimeInterval</span>(<span class="title">timeInterval</span>: <span class="title">NSTimeInterval</span>, <span class="title">repeats</span>: <span class="title">Bool</span> = <span class="title">false</span>, <span class="title">block</span>: () -&gt; ()) -&gt; <span class="title">NSTimer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scheduledTimerWithTimeInterval(timeInterval,</span><br><span class="line">                                          target: <span class="keyword">self</span>,</span><br><span class="line">                                          selector: #selector(_executeBlockFromTimer),</span><br><span class="line">                                          userInfo: <span class="type">FTTimerClosureWraper</span>(timerClosure: block),</span><br><span class="line">                                          repeats: repeats)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">func</span> _executeBlockFromTimer(<span class="title">timer</span>: <span class="title">NSTimer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> timerClosureWraper = timer.userInfo <span class="keyword">as</span>? <span class="type">FTTimerClosureWraper</span> &#123;</span><br><span class="line">      timerClosureWraper.timerClosure()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加上面的方法之后，我们就可以来使用它啦。将 <code>onFireButtonClicked</code> 方法中的 timer 改为如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timer = <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">2</span>, repeats: <span class="literal">true</span>, block: &#123; </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"hey, our block"</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p> 这时候再使用右滑返回，发现会输出 “in deinit”，证明 VC 已经被正确的释放了。</p><p> 当然，如果你在闭包中捕获了 self，记得使用 weak，例如：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timer = <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">2</span>, repeats: <span class="literal">true</span>, block: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">self</span>?.test()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>完整的示例代码可以可以从 <a href="https://github.com/futantan/PrayerBlogCode" target="_blank" rel="noopener">这里</a> 获得。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/" target="_blank" rel="noopener">NSTimer</a></li><li><a href="http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/" target="_blank" rel="noopener">iOS 中的 NSTimer</a></li><li><a href="http://swifter.tips/retain-cycle/" target="_blank" rel="noopener">内存管理，WEAK 和 UNOWNED</a></li><li><a href="http://blog.fivelakesstudio.com/2015/11/nstimer-and-blocks-closures.html" target="_blank" rel="noopener">Swift NSTimer and Blocks (Closures)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/14605987599888.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;来看看你是否被 NSTimer 坑过吧 ^_^&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.futantan.com/tags/iOS/"/>
    
      <category term="NSTimer" scheme="http://www.futantan.com/tags/NSTimer/"/>
    
  </entry>
  
  <entry>
    <title>iOS9：预览特定的 UITableViewCell 视图</title>
    <link href="http://www.futantan.com/2016/04/12/peek-pop-view-inside-tableviewcell/"/>
    <id>http://www.futantan.com/2016/04/12/peek-pop-view-inside-tableviewcell/</id>
    <published>2016-04-12T14:40:57.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.natashatherobot.com/peek-pop-view-inside-tableviewcell/" target="_blank" rel="noopener">原文链接</a><br><a href="http://swift.gg/2016/04/12/peek-pop-view-inside-tableviewcell/" target="_blank" rel="noopener">SwiftGG 链接</a><br>作者：Natasha<br>原文日期：2016-02-13<br>译者：<a href="http://www.futantan.com/">Prayer</a><br>校对：<a href="http://www.swiftyper.com/" target="_blank" rel="noopener">小锅</a><br>定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p><a id="more"></a><p>在过去的几天中，我一直忙于开发 <a href="https://github.com/NatashaTheRobot/trySwiftApp" target="_blank" rel="noopener">try! Swift 会议的官方 App</a>（只剩两周半的时间了，我的天哪😱）！项目中一大亮点就是，我要实现在 app 中使用 3D Touch 来支持演讲者和展示的内容的弹窗预览（Peek &amp; Pop）。幸运的是，<a href="https://twitter.com/allonsykraken" target="_blank" rel="noopener">@allonsykraken</a>的博文<a href="http://krakendev.io/peek-pop/" target="_blank" rel="noopener">Peek &amp; Pop Spirit Guide</a>让这个任务完成起来比较简单，为 table view 主视图添加 3D Touch 仅仅花费了几分钟时间就搞定了。</p><center><br><img src="http://swiftgg-main.b0.upaiyun.com/img/peek-pop-view-inside-tableviewcell-1.gif" alt="1.gif"><br></center><p>然而，在 Q&amp;A 模块中遇到了一些问题。我希望在 cell 中特定的视图上——<strong>演讲者的图片</strong>——来使用 peek &amp; pop，而不是像其他模块那样，在整个 cell 上使用。</p><center><br><img src="http://swiftgg-main.b0.upaiyun.com/img/peek-pop-view-inside-tableviewcell-2.gif" alt="2.gif"><br></center><p>因为这个花费了很长时间才解决，所以我想把它记录下来。（在阅读本文之前，请先阅读<a href="http://krakendev.io/peek-pop/" target="_blank" rel="noopener">Peek &amp; Pop Spirit Guide</a>）</p><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><p>为了能够使用 Peak &amp; Pop 功能，我们需要遵循 <strong>UIViewControllerPreviewingDelegate</strong> 协议——这个协议会告知我们用户使用 3D Touch 功能点击了哪儿，并且在这里返回相应的 ViewController 实例。</p><p>因为我的这些图片存在于 cell 中，需要能够区别出用户使用 3D Touch 点击了哪个演讲者的图片，这里我让 cell 遵循 UIViewControllerPreviewingDelegate：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QASessionTableViewCell</span></span><br><span class="line"><span class="comment">// QASessionTableViewCell here: https://github.com/NatashaTheRobot/trySwiftApp/blob/master/trySwift/QASessionTableViewCell.swift</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">QASessionSpeakerPopDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// view controller 将遵循该协议，来正确的设置导航视图</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onCommitViewController</span><span class="params">(viewController: UIViewController)</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">QASessionTableViewCell</span>: <span class="title">UIViewControllerPreviewingDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// UIViewControllerPreviewingDelegate conformance</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">previewingContext</span><span class="params">(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint)</span></span> -&gt; <span class="type">UIViewController</span>? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> viewsTo3DTouch = [speaker1ImageView, speaker2ImageView, speaker3ImageView]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (index, view) <span class="keyword">in</span> viewsTo3DTouch.<span class="built_in">enumerate</span>() <span class="keyword">where</span> touchedView(view, location: location) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> speaker = qaSession?.speakers[index] &#123;</span><br><span class="line">                <span class="comment">// 返回显示 peek &amp; pop 功能所需要的控制器</span></span><br><span class="line">                <span class="keyword">return</span> viewControllerForSpeaker(speaker)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">previewingContext</span><span class="params">(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController)</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果用户选择 pop 出视图，我们需要跳转到相应的视图控制器</span></span><br><span class="line">        <span class="comment">// 在设置 cell 的时候，delegate 将会被赋值</span></span><br><span class="line">        delegate?.onCommitViewController(viewControllerToCommit)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// helper methods</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">touchedView</span><span class="params">(view: UIView, location: CGPoint)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> locationInView = view.convertPoint(location, fromView: contentView)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGRectContainsPoint</span>(view.bounds, locationInView)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">viewControllerForSpeaker</span><span class="params">(speaker: Speaker)</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> speakerDetailVC = <span class="type">SpeakerDetailViewController</span>()</span><br><span class="line">        speakerDetailVC.speaker = speaker</span><br><span class="line">        <span class="keyword">return</span> speakerDetailVC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// QASessionsTableViewController</span></span><br><span class="line"><span class="comment">// 全部的代码地址: https://github.com/NatashaTheRobot/trySwiftApp/blob/master/trySwift/QASessionsTableViewController.swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">QASessionsTableViewController</span>: <span class="title">QASessionSpeakerPopDelegate</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 当视图 pop 出来的时候，view controller 负责处理跳转</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onCommitViewController</span><span class="params">(viewController: UIViewController)</span></span> &#123;</span><br><span class="line">        navigationController?.pushViewController(viewController, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于，想要使用 Peek &amp; Pop 功能，我们需要使用 <strong>registerForPreviewingWithDelegate</strong> 来注册视图和设置代理，但是 registerForPreviewingWithDelegate 是 UIViewController 中的方法，所以我们不能够在 cell 的代码中注册视图！</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>问题的关键在于，我们现在需要 view controller 中 <strong>注册每一个 cell</strong>（而不是像 Schedule 或 Speaker 模块那样直接注册整个 table view）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QASessionsTableViewController</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QASessionsTableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码有删减</span></span><br><span class="line">    <span class="comment">// 全部的代码地址: https://github.com/NatashaTheRobot/trySwiftApp/blob/master/trySwift/QASessionsTableViewController.swift</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="type">String</span>(<span class="type">QASessionTableViewCell</span>), forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">QASessionTableViewCell</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> qaSession = dataSource.qaSessions[indexPath.section]</span><br><span class="line">        cell.configure(withQASession: qaSession, delegate: <span class="keyword">self</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这是见证奇迹的时刻</span></span><br><span class="line">        <span class="comment">// 我们需要注册每一个 cell</span></span><br><span class="line">        <span class="keyword">if</span> traitCollection.forceTouchCapability == .<span class="type">Available</span> &#123;</span><br><span class="line">            registerForPreviewingWithDelegate(cell, sourceView: cell.contentView)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p><a href="https://twitter.com/davedelong/status/698527490428383232" target="_blank" rel="noopener">@davedelong 指出</a><strong>在 cell 中创建添加到 navigation 中的控制器看起来不是一个明智的选择。</strong> 我完全同意他的观点！但是写代码的时候在 deadline 的压迫下，我没有想到更好的实现方式。幸运的是，<a href="https://twitter.com/NatashaTheRobot/status/698530746449817600" target="_blank" rel="noopener">@davedelong 提出了一种更好的解决办法</a>，通过这种方式，可以让这些代码保留在应有的 view controller 中！</p><p>下面的代码经过了一些重构，希望你能够 get 到其中的精髓！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QASessionsTableViewController</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QASessionsTableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> dataSource: <span class="type">QASessionDataSourceProtocol</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// other setup here</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 只需要为 force touch 注册整个 table view</span></span><br><span class="line">        <span class="comment">// 不需要分别注册单个的 cell</span></span><br><span class="line">        <span class="keyword">if</span> traitCollection.forceTouchCapability == .<span class="type">Available</span> &#123;</span><br><span class="line">            registerForPreviewingWithDelegate(<span class="keyword">self</span>, sourceView: tableView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 代码有删减</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// MARK: Force Touch on Speaker Images</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">QASessionsTableViewController</span>: <span class="title">UIViewControllerPreviewingDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">previewingContext</span><span class="params">(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint)</span></span> -&gt; <span class="type">UIViewController</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> indexPath = tableView.indexPathForRowAtPoint(location) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">let</span> cell = tableView.cellForRowAtIndexPath(indexPath) <span class="keyword">as</span>! <span class="type">QASessionTableViewCell</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> viewsTo3DTouch = [cell.speaker1ImageView, cell.speaker2ImageView, cell.speaker3ImageView]</span><br><span class="line">            <span class="keyword">for</span> (index, view) <span class="keyword">in</span> viewsTo3DTouch.<span class="built_in">enumerate</span>() <span class="keyword">where</span> touchedView(view, location: location) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 只将图片清晰地显示，其他内容将会变得模糊</span></span><br><span class="line">                <span class="comment">// 需要将 image view 的坐标转化为在 table view 坐标系中的坐标 </span></span><br><span class="line">                <span class="comment">// 如果你有更好的坐标转换方式，请告诉我！</span></span><br><span class="line">                <span class="keyword">let</span> viewRectInTableView = tableView.convertRect(view.frame, fromCoordinateSpace: view.superview!)</span><br><span class="line">                previewingContext.sourceRect = viewRectInTableView</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置需要显示的 view controller</span></span><br><span class="line">                <span class="keyword">let</span> qaSession = dataSource.qaSessions[indexPath.section]</span><br><span class="line">                <span class="keyword">let</span> speaker = qaSession.speakers[index]</span><br><span class="line">                <span class="keyword">return</span> viewControllerForSpeaker(speaker)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">previewingContext</span><span class="params">(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController)</span></span> &#123;</span><br><span class="line">        navigationController?.pushViewController(viewControllerToCommit, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">touchedView</span><span class="params">(view: UIView, location: CGPoint)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> locationInView = view.convertPoint(location, fromView: tableView)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGRectContainsPoint</span>(view.bounds, locationInView)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">viewControllerForSpeaker</span><span class="params">(speaker: Speaker)</span></span> -&gt; <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> speakerDetailVC = <span class="type">SpeakerDetailViewController</span>()</span><br><span class="line">        speakerDetailVC.speaker = speaker</span><br><span class="line">        <span class="keyword">return</span> speakerDetailVC</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是效果图——请注意，选中的图片之外的内容才会变得模糊！</p><center><br><img src="http://swiftgg-main.b0.upaiyun.com/img/peek-pop-view-inside-tableviewcell-3.gif" alt="3.gif"><br></center><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以在某个特定的视图上使用 3D Touch 功能并非难事！一般来说，实现 3D Touch 非常简单和有趣。我强烈推荐您在 app 中添加 3D Touch 的功能。</p><center><br><img src="https://www.natashatherobot.com/wp-content/uploads/peekpop.jpg" alt="peak and pop all the things"><br></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.natashatherobot.com/peek-pop-view-inside-tableviewcell/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://swift.gg/2016/04/12/peek-pop-view-inside-tableviewcell/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SwiftGG 链接&lt;/a&gt;&lt;br&gt;作者：Natasha&lt;br&gt;原文日期：2016-02-13&lt;br&gt;译者：&lt;a href=&quot;http://www.futantan.com/&quot;&gt;Prayer&lt;/a&gt;&lt;br&gt;校对：&lt;a href=&quot;http://www.swiftyper.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小锅&lt;/a&gt;&lt;br&gt;定稿：&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shanks&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://www.futantan.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://www.futantan.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>铲屎官翻身记（Slack bot）</title>
    <link href="http://www.futantan.com/2016/04/06/create-a-slack-bot/"/>
    <id>http://www.futantan.com/2016/04/06/create-a-slack-bot/</id>
    <published>2016-04-06T02:11:30.000Z</published>
    <updated>2017-10-28T04:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/14599097880604.jpg" alt=""></p><p>今天来做一回翻身的铲屎官，使用 Slack bot 来简化我们的工作流程。（主要是因为我的 bot 以 miao 命名，所以 😂 ）</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://hubot.github.com/" target="_blank" rel="noopener">Hubot</a> 是一个机器人，可以帮助我们完成很多事情，一个懒癌患者， 宁愿花 3 个小时写代码，也不愿意花 2 个小时完成重复的工作，所以，如果你有懒癌的话，不妨试试 Hubot。这里我将与 Slack 结合使用。</p><p>你可以从<a href="https://hubot.github.com/docs/" target="_blank" rel="noopener">这里</a>查看 Hubot 的使用说明。如果同我一样，是使用 Slack 的话，可以在<a href="https://github.com/slackhq/hubot-slack" target="_blank" rel="noopener">这里</a> 查看如何使用 hubot－slack。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="https://github.com/slackhq/hubot-slack" target="_blank" rel="noopener">Readme 文件</a> 已经写得很清楚了，这里也记录一下吧。</p><p>```bash<br>npm install -g hubot coffee-script yo generator-hubot<br>mkdir -p /path/to/hubot<br>cd /path/to/hubot<br>yo hubot<br>npm install hubot-slack –save<br>```</p><p>上述代码正确执行完毕之后，你的小机器人就可以正常运行了。你可以使用一下命令在本地进行测试：</p><p>```bash<br>HUBOT_SLACK_TOKEN=xxxx-xxxx-xxxx-xxxx-xxxx ./bin/hubot –adapter slack<br>```<br>注意 <code>HUBOT_SLACK_TOKEN＝</code>后面的值需要求改为你的 token。你需要在 <code>Slack-&gt;Browse apps-&gt;Hubot</code> 中新建一个，然后在这里取得 token 的值。</p><p>OK，我们会在下一次介绍如何调教我们的 bot，下次见。</p><p>Happy Hacking!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/14599097880604.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天来做一回翻身的铲屎官，使用 Slack bot 来简化我们的工作流程。（主要是因为我的 bot 以 miao 命名，所以 😂 ）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Slack" scheme="http://www.futantan.com/tags/Slack/"/>
    
  </entry>
  
  <entry>
    <title>使用 IB 填坑记</title>
    <link href="http://www.futantan.com/2016/04/05/tips-for-IB/"/>
    <id>http://www.futantan.com/2016/04/05/tips-for-IB/</id>
    <published>2016-04-05T13:23:12.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在自定义控件的时候，我们经常需要不断的运行程序来查看控件效果是否符合要求，但是每次编译运行都很浪费时间，所以我特别喜欢使用 IB 来预览效果。这篇博文主要记录两点使用注意事项。</p><a id="more"></a><h2 id="IBInspectable"><a href="#IBInspectable" class="headerlink" title="IBInspectable"></a>IBInspectable</h2><p>在使用<code>@IBInspectable</code>来标注属性的时候，一定要显式的指明变量类型，而不是用 type infer。如果不显式的指定，IB 将不能够识别这个属性。例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bgColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.grayColor() &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    bgLayer.strokeColor = bgColor.<span class="type">CGColor</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有显示的指定变量类型为 <code>UIColor</code> IB 中将不会有这个属性的选项。</p><h2 id="Runtime-Attributes"><a href="#Runtime-Attributes" class="headerlink" title="Runtime Attributes"></a>Runtime Attributes</h2><p>你可以参考我的<a href="http://www.futantan.com/2015/09/17/adding-user-defined-runtime-attrubute/">这篇文章</a>来看看 运行时属性 的功能。<br>其实，我们使用 <code>@IBInspectable</code> 的时候，其原理也是使用 Runtime Attributes 来进行属性的赋值：<br><img src="/media/14598631079898.jpg" alt=""></p><p>这里需要注意的是，如果我们将其中的 <code>curValue</code> 从 <code>@IBInspectable</code> 中去掉，记得一定要回到上图这里，将这里的 <code>curValue</code> 手动删除！ Xcode 目前还没这么智能，如果运行时发现有些奇怪的赋值现象，很有可能坑在这里。</p><p>希望这两个坑能够节省你 10 分钟的 debug 时间 ^_^<br>Happy Hacking!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在自定义控件的时候，我们经常需要不断的运行程序来查看控件效果是否符合要求，但是每次编译运行都很浪费时间，所以我特别喜欢使用 IB 来预览效果。这篇博文主要记录两点使用注意事项。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.futantan.com/tags/iOS/"/>
    
      <category term="Interface Builder" scheme="http://www.futantan.com/tags/Interface-Builder/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程之 reduce</title>
    <link href="http://www.futantan.com/2016/04/01/functional-programming-reduce/"/>
    <id>http://www.futantan.com/2016/04/01/functional-programming-reduce/</id>
    <published>2016-04-01T08:13:23.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>与 map 那篇文章类似，我们先来看需求，如果我们需要对一个数组求和，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(xs: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> result: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> xs &#123;</span><br><span class="line">    result += x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面还是来封装变化点。</p><a id="more"></a><p>这里的变化点与之前的 map 和 filter 相比多了一些，除了操作逻辑，类型信息之外，还需要提供一个初始值。封装之后的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;T&gt;<span class="params">(initial: T, combine: <span class="params">(T, Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = initial</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      result = combine(result, x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以像下面这样使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; result, element <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> result + element</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +)</span><br></pre></td></tr></table></figure><p>在 <code>reduce</code> 的定义中，我们提供了两个参数，一个是 <code>initial</code> 提供初始值，同时提供了相关的类型信息，另一个是 <code>combine</code> 函数，将进行相应的转换逻辑。</p><h2 id="使用-reduce-实现-map-和-filter"><a href="#使用-reduce-实现-map-和-filter" class="headerlink" title="使用 reduce 实现 map 和 filter"></a>使用 reduce 实现 map 和 filter</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">mapUsingReduce</span>&lt;T&gt;<span class="params">(transform: Element -&gt; T)</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduce</span>([]) &#123; (result, x) -&gt; [<span class="type">T</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">return</span> result + [transform(x)]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">filterUsingReduce</span><span class="params">(includeElement: Element -&gt; Bool)</span></span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduce</span>([]) &#123; result, x <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">return</span> includeElement(x) ? result + [x] : result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑比较简单明了，就不多说了。需要注意的是，虽然我们可以使用 reduce 来实现 map 和 filter 的功能，但是可以观察到，这里面的性能是不高的，会在运行时造成很多份的数据 copy， 所以，还是使用系统自带的函数吧，源码和编译器都帮我们做了很多的优化。^_^</p><blockquote><p>参考资料 objc Functional Swift</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与 map 那篇文章类似，我们先来看需求，如果我们需要对一个数组求和，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(xs: [Int])&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xs &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result += x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面还是来封装变化点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="函数式编程" scheme="http://www.futantan.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程之 filter</title>
    <link href="http://www.futantan.com/2016/04/01/functional-programming-filter/"/>
    <id>http://www.futantan.com/2016/04/01/functional-programming-filter/</id>
    <published>2016-04-01T03:13:23.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来看需求。从指定的数组中过滤出符合条件的元素，我们先来看简单的情形：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exampleFiles = [<span class="string">"README.md"</span>, <span class="string">"HelloWorld.swift"</span>, <span class="string">"FlappyBird.swift"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSwiftFiles</span><span class="params">(files: [String])</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> result: [<span class="type">String</span>] = []</span><br><span class="line">  <span class="keyword">for</span> file <span class="keyword">in</span> files &#123;</span><br><span class="line">    <span class="keyword">if</span> file.hasSuffix(<span class="string">".swift"</span>) &#123;</span><br><span class="line">      result.append(file)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>与上一篇博客的思路一样，我们来封装变化点，首先是过滤的逻辑，其次是类型信息，最后将其放在 Array 的 extension 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(includeElement: Element -&gt; Bool)</span></span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">Element</span>] = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> <span class="keyword">where</span> includeElement(x) &#123;</span><br><span class="line">      result.append(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的思路非常清晰，于是我们可以像下面一样使用 filter 方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">filter</span>&#123; $<span class="number">0</span> &gt; <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>当然，Swift 标准库中提供了 filter 的实现，定义在 <code>SequenceType</code> 协议中。这里我们只是来自己实现一次。</p><blockquote><p>参考资料 objc Functional Swift</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先来看需求。从指定的数组中过滤出符合条件的元素，我们先来看简单的情形：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; exampleFiles = [&lt;span class=&quot;string&quot;&gt;&quot;README.md&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;HelloWorld.swift&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;FlappyBird.swift&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getSwiftFiles&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(files: [String])&lt;/span&gt;&lt;/span&gt; -&amp;gt; [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result: [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; file &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; files &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; file.hasSuffix(&lt;span class=&quot;string&quot;&gt;&quot;.swift&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      result.append(file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="函数式编程" scheme="http://www.futantan.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程之 map</title>
    <link href="http://www.futantan.com/2016/04/01/functional-programming-map/"/>
    <id>http://www.futantan.com/2016/04/01/functional-programming-map/</id>
    <published>2016-04-01T03:07:13.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们常常需要对一个数组中的每一个元素进行相应的转换，例如，下面这个函数将数组中的每个元素增加 1.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementArray</span><span class="params">(xs: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> result: [<span class="type">Int</span>] = []</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> xs &#123;</span><br><span class="line">    result.append(x + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>然而仔细考虑之后我们会发现，如果有其他的转化操作，就需要再重新写一个函数，而其他的代码逻辑都是相同的，所以，这里我们可以将转化部分的逻辑抽取成一个闭包，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomeThingOnArray</span><span class="params">(xs: [Int], transform: Int -&gt; Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> result: [<span class="type">Int</span>] = []</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> xs &#123;</span><br><span class="line">    result.append(transform(x))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就将会变化的代码抽取出来了，例如将所有元素乘 2:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomeThingOnArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; (element) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> element * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而代码写到这里，并不是一个很好的版本，因为这里的类型的信息是硬编码的，所以，我们来解决这个问题，并且将代码放到 Array 的 extension 中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(transform: Element -&gt; T)</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">T</span>] = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      result.append(transform(x))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们就可以像下面这样使用我们自己定义的 map：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span> &#123; (x) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Swift 标准库中提供了 map 的实现，定义在 <code>SequenceType</code> 协议中。</p><blockquote><p>参考资料 objc Functional Swift</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们常常需要对一个数组中的每一个元素进行相应的转换，例如，下面这个函数将数组中的每个元素增加 1.&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;incrementArray&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(xs: [Int])&lt;/span&gt;&lt;/span&gt; -&amp;gt; [&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result: [&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xs &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result.append(x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="函数式编程" scheme="http://www.futantan.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2016 一季度总结</title>
    <link href="http://www.futantan.com/2016/03/31/2016-first-quarter/"/>
    <id>http://www.futantan.com/2016/03/31/2016-first-quarter/</id>
    <published>2016-03-31T07:37:36.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/14594143449846.jpg" alt=""></p><p>在我写下这些文字的时候，成都大概从冬天直接入夏了。最公平也是最残酷的事情就是时间了吧。今天看书的时候注意到一个单词，Time flies，时光飞逝，我更愿意把它理解为『时间果蝇』，也算是一件有趣的事吧。</p><a id="more"></a><p>这篇博文的目的是为了记流水账，写写这一季度我做了什么，这是我最讨厌的文章类型，所以我打算扯扯淡，各位看官，莞尔一笑也就作罢了。</p><h2 id="故事的开始是别离"><a href="#故事的开始是别离" class="headerlink" title="故事的开始是别离"></a>故事的开始是别离</h2><p>The most hard time it had ever been.</p><p>我把这一段，全部都删掉了。</p><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>感谢每周都要去市里，让我有了很多的时间可以阅读，在地铁上，公交上，除了观察别人，最有意思的就是读书了。很难得的，今年少有的看了几本非技术书，也算是挺幸运的吧。</p><h3 id="《乖，摸摸头》"><a href="#《乖，摸摸头》" class="headerlink" title="《乖，摸摸头》"></a>《乖，摸摸头》</h3><p>这是别人推荐给我的，文章不长，我大概可以一个下午读完，可是同另一本书一样，我读了很长时间，因为，真的不忍去读。</p><p><img src="/media/14594114252719.jpg" alt=""></p><p>你会觉得，啊，为什么他们活得这么洒脱，活得这么自由，活得这么像个无拘无束的精灵。每读一个故事，我都会把手机丢在一边，怅然若失，生怕别人发现我活得这么贫瘠，这么苍白。读完这本书之后，我也常常在想，到底什么是生活，和身边的几个朋友也有所讨论，我不觉得谈论生命的意义是一个很不正常的事情，我恰恰为自己时常思考感到庆幸，虽然我知道生在这个时代，会有强大的时代烙印，但是，我总是要想一想，努力的想一想，努力的思考一下，博上帝一笑吧。</p><h3 id="《皮囊》"><a href="#《皮囊》" class="headerlink" title="《皮囊》"></a>《皮囊》</h3><p><img src="/media/14594117787631.jpg" alt=""></p><p>这也是一本不忍去读的书，作者把人性看得太透，却从一个旁观者的角度，不哭，不闹，让你看到真实的一切，没有血淋淋，却残忍的不忍去读。书中有很多故事，其实都能在自己的身上找到影子吧，或者这也是本书最残酷的事情，他把这原本你没意识到的一切，撕碎了给你看，喏，这就是你的生活。</p><h3 id="《微信帝国》"><a href="#《微信帝国》" class="headerlink" title="《微信帝国》"></a>《微信帝国》</h3><p>做产品的都应该看看这本书，性与暴力，强烈推荐。<br><img src="/media/14594127218197.jpg" alt=""></p><h3 id="《代码之髓》"><a href="#《代码之髓》" class="headerlink" title="《代码之髓》"></a>《代码之髓》</h3><p>这应该是今年我在地铁上读完的第一本书，作者是名日本人，我发觉日本人写的书的视角都比较大，不像国内的书，大部分都教你如何使用 API，顺便推荐一下 Ruby 之父的 《代码的未来》</p><p><img src="/media/14594122979372.jpg" alt=""></p><p>我喜欢看着一类的书，会帮助你思考，为什么会这样。我们每天都在用的编程语言，他的设计哲学和底层原理，如果你对这个该兴趣，你可以看看，这本书比较浅显，可能大部分的问题你都思考过，不过他帮你形成了系统，总结了一下，也算是非常不错的。</p><hr><p>还有好多在读的书，就不列出来了，因为不算是这个季度读完的，也算是对自己的鞭策吧（没读完出来吹什么牛逼…）『多看』上的统计，我大概看了 400 多本书，读完的也就 40 多本，很多书可能看到一般不是很感兴趣就丢掉了。如果你有什么好的书推荐，我相信你总会在我的网站找到我的联系方式的。</p><h2 id="荒唐言"><a href="#荒唐言" class="headerlink" title="荒唐言"></a>荒唐言</h2><p>读了几本书，经历了一些人和事，又过去一个季度。回头看看，这一个季度过得还是挺平淡的，无非就是读书，喜怒哀乐。最近一个月在忙着看书找实习，大概两周没怎么写代码了，最近再看 Functional Programming，希望能在清明前刷完。</p><p>这是我的第一季度，希望下次写的时候，看看这篇文章，“瞧，傻哔，你最近都干了些什么！”</p><p>如果你看到这儿，你可能也是够无聊的，不妨联系我，找我聊聊天吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/14594143449846.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在我写下这些文字的时候，成都大概从冬天直接入夏了。最公平也是最残酷的事情就是时间了吧。今天看书的时候注意到一个单词，Time flies，时光飞逝，我更愿意把它理解为『时间果蝇』，也算是一件有趣的事吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="荒唐言" scheme="http://www.futantan.com/tags/%E8%8D%92%E5%94%90%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Blocks 小测验</title>
    <link href="http://www.futantan.com/2016/03/10/objective-c-blocks-quiz/"/>
    <id>http://www.futantan.com/2016/03/10/objective-c-blocks-quiz/</id>
    <published>2016-03-10T12:05:07.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/14576119117357.jpg" alt=""></p><p>图题是一个很有意思的网站的截图，有人专门申请了一个域名：<a href="http://fuckingblocksyntax.com/" target="_blank" rel="noopener">fuckingblocksyntax</a> 来表示对 OC 中 block 奇特写法的不满，当然题图无关，今天看到一个有意思的 block 测试网站，记录一下。</p><p>你可以在这里来先测试一下：<br><a href="http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/" target="_blank" rel="noopener">Objective-C Blocks Quiz</a></p><a id="more"></a><h2 id="Example-A"><a href="#Example-A" class="headerlink" title="Example A"></a>Example A</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void exampleA() &#123;</span><br><span class="line">  char a = &apos;A&apos;;</span><br><span class="line">  ^&#123;</span><br><span class="line">    printf(&quot;%cn&quot;, a);</span><br><span class="line">  &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：<br>这段代码在 MRC 和 ARC 的情况下都能正确执行。<br>因为 <code>exampleA</code> 的函数栈，在 block 执行完之前，并不会 pop，所以，无论函数中的 block 是在 stack 或是 heap 中，都能够被正确执行。</p><h2 id="Example-B"><a href="#Example-B" class="headerlink" title="Example B"></a>Example B</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void exampleB_addBlockToArray(NSMutableArray *array) &#123;</span><br><span class="line">  char b = &apos;B&apos;;</span><br><span class="line">  [array addObject:^&#123;</span><br><span class="line">    printf(&quot;%cn&quot;, b);</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exampleB() &#123;</span><br><span class="line">  NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">  exampleB_addBlockToArray(array);</span><br><span class="line">  void (^block)() = [array objectAtIndex:0];</span><br><span class="line">  block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：<br>这段代码只有在 ARC 的情况下才能正确执行。<br>在 MRC 的情况下，block 分配在栈上，在 <code>exampleB_addBlockToArray</code> 返回之后，函数栈被弹出，这个 block 的地址就不再合法了。<br>在 ARC 的情况下，block 将会被拷贝到堆中，可以合法使用。</p><h2 id="Example-C"><a href="#Example-C" class="headerlink" title="Example C"></a>Example C</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void exampleC_addBlockToArray(NSMutableArray *array) &#123;</span><br><span class="line">  [array addObject:^&#123;</span><br><span class="line">    printf(&quot;Cn&quot;);</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exampleC() &#123;</span><br><span class="line">  NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">  exampleC_addBlockToArray(array);</span><br><span class="line">  void (^block)() = [array objectAtIndex:0];</span><br><span class="line">  block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：<br>这段代码在 MRC 和 ARC 的情况下都能正确执行。<br>因为 <code>exampleC_addBlockToArray</code> 中的 block 并没有捕获任何变量，是一个 <code>NSGlobalBlock</code>，既不在堆中，也不在栈上，所以可以像普通的 C 函数一样访问，不会存在任何问题。</p><h2 id="Exapmle-D"><a href="#Exapmle-D" class="headerlink" title="Exapmle D"></a>Exapmle D</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^dBlock)();</span><br><span class="line"></span><br><span class="line">dBlock exampleD_getBlock() &#123;</span><br><span class="line">  char d = &apos;D&apos;;</span><br><span class="line">  return ^&#123;</span><br><span class="line">    printf(&quot;%cn&quot;, d);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exampleD() &#123;</span><br><span class="line">  exampleD_getBlock()();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：<br>这段代码只有在 ARC 的情况下才能正确执行。<br>block 分配在栈上，如果是 ARC，将会被拷贝到堆上。而 MRC 的情况下，函数执行结束，这个地址就不存在了，而且编译器会报错：<code>error: returning block that lives on the local stack</code></p><h2 id="Example-E"><a href="#Example-E" class="headerlink" title="Example E"></a>Example E</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^eBlock)();</span><br><span class="line"></span><br><span class="line">eBlock exampleE_getBlock() &#123;</span><br><span class="line">  char e = &apos;E&apos;;</span><br><span class="line">  void (^block)() = ^&#123;</span><br><span class="line">    printf(&quot;%cn&quot;, e);</span><br><span class="line">  &#125;;</span><br><span class="line">  return block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exampleE() &#123;</span><br><span class="line">  eBlock block = exampleE_getBlock();</span><br><span class="line">  block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：<br>这段代码只有在 ARC 的情况下才能正确执行。<br>和 <code>Exapmle D</code> 的情况很类似，只不过这儿编译器在 MRC 情况下不会报错。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>ARC</code> 大法好！<br>如果不使用 ARC（我觉得现在应该没有不用 ARC 的吧…）需要在传递 block 的时候，使用 <code>block = [[block copy] autorelease]</code>，这样可以让 block 拷贝到堆中。</p><p>声明：本文内容并非原创，而是大部分引用自上面所说的<a href="http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/" target="_blank" rel="noopener">网站</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/14576119117357.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图题是一个很有意思的网站的截图，有人专门申请了一个域名：&lt;a href=&quot;http://fuckingblocksyntax.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fuckingblocksyntax&lt;/a&gt; 来表示对 OC 中 block 奇特写法的不满，当然题图无关，今天看到一个有意思的 block 测试网站，记录一下。&lt;/p&gt;
&lt;p&gt;你可以在这里来先测试一下：&lt;br&gt;&lt;a href=&quot;http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Objective-C Blocks Quiz&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-c" scheme="http://www.futantan.com/tags/Objective-c/"/>
    
  </entry>
  
  <entry>
    <title>Realm 入坑系列之 String 数组</title>
    <link href="http://www.futantan.com/2016/03/06/fuck-realm-string-array/"/>
    <id>http://www.futantan.com/2016/03/06/fuck-realm-string-array/</id>
    <published>2016-03-06T14:17:48.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Realm 中为了建立一对多的数据模型关系，需要使用 List。List 在使用上和 Array 非常类似，然而，当我们需要表示 Swift 中的基本类型的时候，坑就来了…</p><a id="more"></a><p>假设我们从服务端获取了一个字段 <code>tags</code>，这个字段是一个 String 类型的数组，我们的第一反应是这样来建立数据模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let tags = List&lt;String&gt;()</span><br></pre></td></tr></table></figure><p>然而编译器会无情打脸</p><p><img src="/media/14572748135230.jpg" alt=""><br>在 Realm 中，数据类型必须继承自 <code>Object</code>，这一点都不酷，真的…</p><p>在查看了很久官方文档之后，得出一个结论，这种写法确实是不行的。于是你必须在为了表示 String 类型，而将 String 在包裹在一个 继承自 Object 的类中，向如下的写法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealmString</span>: <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> stringValue = <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实这是目前唯一的解决办法，如果你有更好的解决方案，可以留言。</p><p>当然，在我们无法改变结果的时候，就让我们来完善一下过程，将上面的变量声明代码改为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _backingTags = <span class="type">List</span>&lt;<span class="type">RealmString</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> tags: [<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _backingTags.<span class="built_in">map</span> &#123; $<span class="number">0</span>.stringValue &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123;</span><br><span class="line">    _backingTags.removeAll()</span><br><span class="line">    _backingTags.appendContentsOf(newValue.<span class="built_in">map</span>(&#123; <span class="type">RealmString</span>(value: [$<span class="number">0</span>]) &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们定义了一个计算属性，通过 _backingTags 来作为实际的存储值，然后使用 tags 作为使用的接口，稍微优雅了一点。</p><p>enjoy~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Realm 中为了建立一对多的数据模型关系，需要使用 List。List 在使用上和 Array 非常类似，然而，当我们需要表示 Swift 中的基本类型的时候，坑就来了…&lt;/p&gt;
    
    </summary>
    
      <category term="Realm 入坑系列" scheme="http://www.futantan.com/categories/Realm-%E5%85%A5%E5%9D%91%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Realm" scheme="http://www.futantan.com/tags/Realm/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中日期的格式化操作</title>
    <link href="http://www.futantan.com/2016/03/05/dateformat-in-iOS/"/>
    <id>http://www.futantan.com/2016/03/05/dateformat-in-iOS/</id>
    <published>2016-03-05T12:01:07.000Z</published>
    <updated>2017-10-27T09:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更新： 收藏这个网址 <a href="http://nsdateformatter.com/" target="_blank" rel="noopener">nsdateformatter</a>，这篇博客不用看了！</p></blockquote><p>在和服务器交互数据的时候，使用到 NSDate，无论是将服务器返回的 String 类型的日期字符串转为 NSDate，还是 NSDate 到 String 类型的逆向处理，都是经常要做的事情，这里主要是和大家分享一个特别棒的网站。</p><a id="more"></a><h2 id="String-To-Date"><a href="#String-To-Date" class="headerlink" title="String To Date"></a>String To Date</h2><p>来看一个具体的场景，比如，服务器端给我们返回的日期字段为 <code>2016-03-05T11:35:05Z</code>，String 类型，我们使用下面的做法来处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringToDateFormatter = <span class="type">NSDateFormatter</span>()</span><br><span class="line">stringToDateFormatter.dateFormat = <span class="string">"yyyy-MM-dd'T'kk:mm:ssZ"</span></span><br><span class="line">stringToDateFormatter.timeZone = <span class="type">NSTimeZone</span>.localTimeZone()</span><br><span class="line"><span class="keyword">let</span> date = stringToDateFormatter.dateFromString(dateString)</span><br></pre></td></tr></table></figure><p>其实很简单，关键在于 “yyyy-MM-dd’T’kk:mm:ssZ”，如何快速正确的写出这个 format 字符串呢，给大家推荐一个网站 <a href="http://userguide.icu-project.org/formatparse/datetime" target="_blank" rel="noopener">Formatting Dates and Times</a></p><p><img src="/media/14571797012126.jpg" alt=""></p><p>amazing！再也不用担心不会写日期格式化字符串了！</p><h2 id="Date-To-String"><a href="#Date-To-String" class="headerlink" title="Date To String"></a>Date To String</h2><p>现在我们来将 NSDate 转为 想要的 String 类型，比如上面的时间，我想要的输出是 “Mar 5, 2016”<br>可以使用如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dateToStringFormatter = <span class="type">NSDateFormatter</span>()</span><br><span class="line">dateToStringFormatter.dateFormat = <span class="string">"MMM d, yyyy"</span> <span class="comment">//Mar 5, 2016</span></span><br><span class="line"><span class="built_in">print</span>(dateToStringFormatter.stringFromDate(date!))</span><br></pre></td></tr></table></figure><p>希望看完这篇博文，在以后遇到类似情况的时候，能够节省下您 5 分钟的搜索时间。<br>enjoy~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更新： 收藏这个网址 &lt;a href=&quot;http://nsdateformatter.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nsdateformatter&lt;/a&gt;，这篇博客不用看了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在和服务器交互数据的时候，使用到 NSDate，无论是将服务器返回的 String 类型的日期字符串转为 NSDate，还是 NSDate 到 String 类型的逆向处理，都是经常要做的事情，这里主要是和大家分享一个特别棒的网站。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://www.futantan.com/tags/iOS/"/>
    
  </entry>
  
</feed>
